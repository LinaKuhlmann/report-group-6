[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Final report – Advanced Energetics",
    "section": "",
    "text": "Abstract\nThis is the template for the Advanced Energetics project report. Its purpose is to guide you in creating a high-quality report. It includes both general writing instructions and project-specific guidelines. When submitting your final group report, please replace the guidelines with your own content.\nGrading standards 1\nThe project report will be evaluated based on the following criterias:\nHow to write an abstract\nLet us begin with the abstract. A standard abstract typically comprises the following components:\nAn illustrative example for your reference is provided below:"
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Final report – Advanced Energetics",
    "section": "",
    "text": "We start with complete transparency and clarity.↩︎"
  },
  {
    "objectID": "01.00-intro.html",
    "href": "01.00-intro.html",
    "title": "1  Title",
    "section": "",
    "text": "2 Introduction\nIn the introduction, consider addressing the following questions relevant to your project:\n\nWhat is the background and motivation behind your project? Why do you wish to undertake process integration and optimization for the dairy factory?\nWhat are the primary challenges and issues you aim to tackle in this study? Is it focused on heat exchanger network design and/or utility integration?\nIs there existing work similar to yours in this domain? If so, what are the contributions and limitations of their research?\nWhat contributions do you intend to make through your project?\nHow have you organized your project report to effectively convey your findings and insights?\n\nYou do not need to answer all of these questions explicitly, but ensure that your introduction provides a clear and comprehensive understanding of the problem and its context.\nThis project involves a comprehensive examination of how Mrs. Pacometer, a dairy owner, can enhance the efficiency of her dairy process energetically and economically."
  },
  {
    "objectID": "02.00-process_description.html#pasteurisation",
    "href": "02.00-process_description.html#pasteurisation",
    "title": "2  Process description and analysis",
    "section": "2.1 Pasteurisation",
    "text": "2.1 Pasteurisation\n\n\n\nPasteurisation\n\n\nIn this section will be presented the mass and energy balances for each chemical operation of the milk pasteurisation. This pasterisation aims to produce cream and milk from fresh milk with the intergation of a thickener at some point.\n\n2.1.1 Mass Flows\nBecause of the mass flow conservation, we have:\n\n\\begin{cases}\n    \\dot m_{Mixure~out} = \\dot m_{Past{\\_}Cent}=\\dot m_{Fresh~Milk}=8~kg/s \\\\\n    \\dot m_{Milk{\\_}0} = \\dot m_{Past{\\_}a} = \\dot m_{Past{\\_}b} = \\dot m_{Past{\\_}c} =  \\dot m_{Past{\\_}d} = \\dot m_{Milk} = 7.52~kg/s \\\\\n    \\dot m_{cream{\\_}0} = \\dot m_{crpast{\\_}a} = \\dot m_{Past{\\_}cent} - \\dot m_{Milk{\\_}0} =  \\dot m_{Fresh~Milk} - \\dot m_{Milk} = 8 - 7.52 = 0.48~kg/s \\\\\n    \\dot m_{crpast{\\_}x} = \\dot m_{crpast{\\_}b} = \\dot m_{crpast{\\_}c} = \\dot m_{Cream} =  0.55~kg/s \\\\\n    \\dot m_{thickener} = 0.07~kg/s\n\\end{cases}\n\nConsequently, all mass flows are defined.\n\n\n2.1.2 Heat Capacities\nThe following heat capacities are already provided :\n\nc_{p,Raw~Milk} = 3.8 kJ/(kgK) (milk after centrifuge)\nc_{p,Cream~ac} = 3.4 kJ/(kgK) (cream after centrifuge)\n\nFrom Litterature Naghavi, Dehghannya, and Ghanbarzadeh (2018) we chose:\n\nc_{p,thickener} = c_{p,alginate} = 4.175 kJ/(kg.K)\n\nAssuming that the mixer provides an ideal mix, we have:\n\n\\begin{align*}\n    c_{p,cream} &= \\frac{\\dot m_{cream{\\_}0}}{\\dot m_{Cream}} \\cdot c_{p,Cream~ac} + \\frac{\\dot m_{thickener}}{\\dot m_{Cream}} \\cdot c_{p,thickener} \\\\\n    \\\\\n    c_{p,cream} &= \\frac{0.48}{0.55} \\cdot 3400 + \\frac{0.07}{0.55} \\cdot 4175\n\\end{align*}\n\nWe also consider the centrifuge separes an ideal mix, therefore:\n\n\\begin{align*}\n    c_{p,fresh{\\_}milk} &= \\frac{\\dot m_{cream{\\_}0}}{\\dot m_{fresh{\\_}milk}} \\cdot c_{p,Cream~ac} + \\frac{\\dot m_{Milk{\\_}0} }{\\dot m_{fresh{\\_}milk}} \\cdot c_{p,raw{\\_}milk} \\\\\n    \\\\\n    c_{p,fresh{\\_}milk} &= \\frac{0.48}{8} \\cdot 3400 + \\frac{7.52}{8} \\cdot 3800\n\\end{align*}\n\nFinally:\n\nc_{p,cream} = 3.5~kJ/(kgK)\nc_{p,fresh_milk} = 3.78~kJ/(kgK)\n\n\n\n2.1.3 Equations of operations\nIn this subsection are indicated the heat flow equations for each element of the pasteurisation. All variables are defined whether on the pasteurization scheme or in the mass flow and heat capacities sections. The \\Delta T = 5K is applied on Past2, between Milk_0 and Past_a and on Past 5, between crpast_c and cream. Regarding the glycolic water and the steam, the same temperatures and heat capacities as the one in the beer pasteurization process are used, and it is assumed the exact cooling or the heating are controlled by the mass flow of these elements.\n\n2.1.3.1 Refrigeration\n\n\\begin{align*}\n    \\dot Q_{refrigeration} &= \\dot m_{Fresh~Milk} \\cdot c_{p,Fresh~Milk} \\cdot (T_{Fresh~Milk} - T_{Mixure{\\_}out}) \\\\\n    &= \\dot m_{gliwater{\\_}ref} \\cdot c_{p,gliwater} \\cdot (T_{Gliwater{\\_}out,ref} - T_{Gliwater{\\_}in,ref})\n\\end{align*}\n\\tag{2.1}\n\n\n2.1.3.2 PAST1\n\n\\begin{align*}\n    \\dot Q_{past1} &= \\dot m_{Fresh~Milk} \\cdot c_{p,Fresh~Milk} \\cdot (T_{Past{\\_}cent} - T_{Mixure{\\_}out}) \\\\\n    &= \\dot m_{Milk} \\cdot c_{p,Raw~Milk} \\cdot (T_{Past{\\_}c} - T_{Past{\\_}d})\n\\end{align*}\n\\tag{2.2}\n\n\n2.1.3.3 PAST2\n\n\\begin{align*}\n    \\dot Q_{past2} &= \\dot m_{Milk} \\cdot c_{p,Raw~Milk} \\cdot (T_{Milk{\\_}0} - T_{Past{\\_}a}) \\\\\n    &= \\dot m_{Milk} \\cdot c_{p,Raw~Milk} \\cdot (T_{Past{\\_}c} - T_{Past{\\_}b})\n\\end{align*}\n\\tag{2.3}\n\n\n2.1.3.4 CENTRIFUGE\n\n\\begin{align*}\n    T_{Past{\\_}cent} = T_{Milk{\\_}0} = T_{cream{\\_}0} ~~~~~~(isothermal~mix)\n\\end{align*}\n\\tag{2.4}\n\n\n2.1.3.5 PAST3\n\n\\begin{align*}\n    \\dot Q_{past3} &= \\dot m_{Milk} \\cdot c_{p,Raw~Milk} \\cdot (T_{Milk{\\_}b} - T_{Past{\\_}a}) \\\\\n    &= \\dot m_{steam{\\_}p2} \\cdot c_{p,steam} \\cdot (T_{Steam{\\_}in,p3} - T_{Steam{\\_}out,p3})\n\\end{align*}\n\\tag{2.5}\n\n\n2.1.3.6 PAST4\n\n\\begin{align*}\n    \\dot Q_{past4} &= \\dot m_{Milk} \\cdot c_{p,Raw~Milk} \\cdot (T_{past{\\_}d} - T_{Milk}) \\\\\n    &= \\dot m_{gliwater{\\_}p4} \\cdot c_{p,gliwater} \\cdot (T_{Gliwater{\\_}out,p4} - T_{Gliwater{\\_}in,p4})\n\\end{align*}\n\\tag{2.6}\n\n\n2.1.3.7 PAST5\n\n\\begin{align*}\n    \\dot Q_{past5} &= \\dot m_{Intern} \\cdot c_{p,Cream~ac} \\cdot (T_{cream{\\_}0} - T_{crpast{\\_}a}) \\\\\n    &= \\dot m_{Cream} \\cdot c_{p,Cream} \\cdot (T_{crpast{\\_}c} - T_{crpast{\\_}b})\n\\end{align*}\n\\tag{2.7}\n\n\n2.1.3.8 MIXER\n\n\\begin{align*}\n    \\dot m_{thickener} \\cdot c_{p,thickener} \\cdot (T_{crpast{\\_}x} - T_{thickener})\n    = \\dot m_{intern} \\cdot c_{p,Cream~ac} \\cdot (T_{crpast{\\_}a} - T_{thickener}) \\\\\n\\end{align*}\n\\tag{2.8}\n\n\n2.1.3.9 PAST6\n\n\\begin{align*}\n    \\dot Q_{past6} &= \\dot m_{Cream} \\cdot c_{p,Cream} \\cdot (T_{crpast{\\_}b} - T_{crpast{\\_}x}) \\\\\n    &= \\dot m_{steam{\\_}p6} \\cdot c_{p,steam} \\cdot (T_{Steam{\\_}in,p6} - T_{Steam{\\_}out,p6})\n\\end{align*}\n\\tag{2.9}\n\n\n2.1.3.10 PAST7\n\n\\begin{align*}\n    \\dot Q_{past7} &= \\dot m_{Cream} \\cdot c_{p,Cream} \\cdot (T_{crpast{\\_}c} - T_{Cream}) \\\\\n    &= \\dot m_{gliwater{\\_}p7} \\cdot c_{p,gliwater} \\cdot (T_{Gliwater{\\_}out,p7} - T_{Gliwater{\\_}in,p7})\n\\end{align*}\n\\tag{2.10}\n\n\nCode\nimport pandas as pd\nimport numpy as np\nfrom IPython.display import display, HTML\nfrom codes_01_energy_bill.pasteurisation_functions import heat_exchanger_Q\n\n# Mass flows(kg/s)\n\nm_fmilk = 8\nm_milk = 7.52\nm_cream = 0.55\nm_int = m_fmilk - m_milk\nm_thick = 0.07\n\n# Heat capacities (J/(kg.K))\n\nCp_alboline = 4175\nCp_raw_milk = 3800 # Has been computed with mix\nCp_cream = 3400\nCp_glywater = 3900 #(Beer pasteurization exercise)\nCp_steam = 1996 #(Internet)\nCp_fmilk = (m_int/m_fmilk)*Cp_cream + (m_milk/m_fmilk)*Cp_raw_milk\nCp_cream_mixed = (m_int/m_cream)*Cp_cream + (m_thick/m_cream)*Cp_alboline\n\n\n# Temperatures (K)\n\nT_a=25+273\nT_fmilk = 6+273.15\nT_mixure_out = 4+273.15\nT_past_cent = 60+273.15\nT_milk_0 = T_past_cent\nT_cream_0 = T_past_cent\nT_past_b = 75+273.15\nT_milk = 4+273.15\nT_thick = 4+273.15\nT_crpast_b = 75+273.15\nT_cream = 4+273.15\n\nT_glywater_in = -5 + 273.15\nT_glywater_out = -1 + 273.15\nT_steam_in = 207.336 + 273.15\nT_steam_out = 110 + 273.15\n\n\n# T_past_a, computed later\n# T_past_c, computed later\n# T_past_d, computed later\n# T_crpast_a, computed later\n# T_crpast_x, computed later\n# T_crpast_c, computed later\n\n# Temperatures computation\n\nT_past_c = 5 + T_past_b\nT_past_a = T_past_c - T_past_b + T_milk_0\nT_past_d = - (( m_fmilk / m_milk ) * ( Cp_fmilk / Cp_raw_milk ) * (T_past_cent - T_mixure_out)) + T_past_c\nT_crpast_a = (( m_cream / m_int ) * ( Cp_cream_mixed / Cp_cream ) * 5) + T_cream_0\nT_crpast_c = (( m_int / m_cream ) * ( Cp_cream / Cp_cream_mixed ) * (T_crpast_a - T_cream_0)) + T_crpast_b\nT_crpast_x = ((Cp_alboline*m_thick)*T_thick + (Cp_cream*m_int)*T_crpast_a) / ((Cp_alboline*m_thick)+(Cp_cream*m_int))\n\n# Heat flows computation\n\nQ_refrigeration = heat_exchanger_Q(T_fmilk,T_mixure_out,m_fmilk,Cp_fmilk)\nQ_past1 = heat_exchanger_Q(T_past_cent,T_mixure_out,m_fmilk,Cp_fmilk) \nQ_past2 = heat_exchanger_Q(T_past_a,T_milk_0,m_milk,Cp_raw_milk)\nQ_past3 = heat_exchanger_Q(T_past_a,T_past_b,m_milk,Cp_raw_milk)\nQ_past4 = heat_exchanger_Q(T_past_d,T_milk,m_milk,Cp_raw_milk)\nQ_past5 = heat_exchanger_Q(T_crpast_a,T_crpast_b,m_cream,Cp_cream_mixed)\nQ_past6 = heat_exchanger_Q(T_crpast_x,T_crpast_b,m_cream,Cp_cream_mixed)\nQ_past7 = heat_exchanger_Q(T_cream,T_crpast_c,m_cream,Cp_cream_mixed)\n\n# Computation for steam and glywater\n\nm_gly_ref = Q_refrigeration / ( Cp_glywater * (T_glywater_out-T_glywater_in) )\nm_steam_past3 = Q_past3 / ( Cp_steam * (T_steam_in-T_steam_out) )\nm_gly_past4 = Q_past4 / ( Cp_glywater * (T_glywater_out-T_glywater_in) )\nm_steam_past6 = Q_past6 / ( Cp_steam * (T_steam_in-T_steam_out) )\nm_gly_past7 = Q_past7 / ( Cp_glywater * (T_glywater_out-T_glywater_in) )\n\n# Specific entropy and enthalpy from beer pasteurisation\n\ndelta_s_steam = 7.343e3 - 1.418e3\ndelta_h_steam = 2880.8e3 - 461.368e3\n\n\n#DATAFRAMES\n\n# Dataframe for Heat Flows\n\nEnergy_flow = 'kJ/s'\n\nVariables_Names = ['Refrigeration','Past1','Past2','Past3','Past4','Past5','Past6','Past7']\nVariables_Values = np.divide([Q_refrigeration,Q_past1,Q_past2,Q_past3,Q_past4,Q_past5,Q_past6,Q_past7],1000)\nVariables_Units =  Energy_flow \ndf_pasteurization_heat_flow = pd.DataFrame(data = {'Heat Flow': Variables_Names, 'Value':Variables_Values, 'Unit': Variables_Units})\n\n# Dataframe for Temperatures\n\nTemperature = '°C'\n\nTemperatures_vector = [T_a,T_fmilk,T_mixure_out,T_past_cent,T_milk_0,T_cream_0,T_past_a,T_past_b,T_past_c,T_past_d,T_milk,T_crpast_a,T_thick,T_crpast_x,T_crpast_b,T_crpast_c,T_cream,T_steam_in,T_steam_out,T_glywater_in,T_glywater_out]\nto_celsius = lambda t: t - 273.15\nTemperatures_vector = np.array([to_celsius(x) for x in Temperatures_vector])\nVariables_Names = ['a','fmilk','mixure_out','past_cent','milk_0','cream_0','past_a','past_b','past_c','past_d','milk','crpast_a','thick','crpast_x','crpast_b','crpast_c','cream','steam_in','steam_out','glywater_in','glywater_out']\n\nVariables_Values = Temperatures_vector\nVariables_Units =  Temperature \ndf_pasteurization_temperatures = pd.DataFrame(data = {'Temperature': Variables_Names, 'Value':Variables_Values, 'Unit': Variables_Units})\n\n\n# Dataframe for Mass Flows in the Pasteurisation\n\nMass_flow = 'kg/s'\n\nVariables_Names = ['fresh_milk','milk','cream','intern = fresh_milk - milk','thickener']\nVariables_Values = [m_fmilk,m_milk,m_cream,m_int,m_thick]\nVariables_Units =  Mass_flow \ndf_pasteurization_mf_in = pd.DataFrame(data = {'Mass Flow': Variables_Names, 'Value':Variables_Values, 'Unit': Variables_Units})\n\n# Dataframe for Mass Flows for steam and glywater\n\nMass_flow = 'kg/s'\n\nVariables_Names = ['glywater in refrigeration','steam in past3','glywater in past4','steam in past6','glywater in past4']\nVariables_Values = [m_gly_ref,m_steam_past3,m_gly_past4,m_steam_past6,m_gly_past7 ]\nVariables_Units =  Mass_flow \ndf_pasteurization_mf_steam_gly = pd.DataFrame(data = {'Mass Flow': Variables_Names, 'Value':Variables_Values, 'Unit': Variables_Units})\n\n\n# Dataframe for Heat capacities (J/(kg.K))\n\nHeat_capacity = 'J/(kg.K)'\n\nVariables_Names = ['alboline','raw_milk','cream','glywater','steam','fmilk','cream_mixed']\nVariables_Values = [Cp_alboline,Cp_raw_milk,Cp_cream,Cp_glywater,Cp_steam,Cp_fmilk,Cp_cream_mixed]\nVariables_Units =  Heat_capacity \ndf_pasteurization_heat_capacities = pd.DataFrame(data = {'Heat Capacity': Variables_Names, 'Value':Variables_Values, 'Unit': Variables_Units})\n\n# Dataframe for entropy\n\nSpecific_entropy = 'J/(kg.K)'\n\nVariables_Names = ['delta_s_steam']\nVariables_Values = [delta_s_steam]\nVariables_Units =  Specific_entropy \ndf_pasteurization_entropy = pd.DataFrame(data = {'Specific Entropy': Variables_Names, 'Value':Variables_Values, 'Unit': Variables_Units})\n\n# Dataframe for enthalpy\n\nSpecific_enthalpy = 'J/(kg)'\n\nVariables_Names = ['delta_h_steam']\nVariables_Values = [delta_h_steam]\nVariables_Units =  Specific_enthalpy \ndf_pasteurization_enthalpy = pd.DataFrame(data = {'Specific Enthalpy': Variables_Names, 'Value':Variables_Values, 'Unit': Variables_Units})\n\n#HTML(df_pasteurization_heat_flow.to_html(index=False))\n#HTML(df_pasteurization_temperatures.to_html(index=False))\n#HTML(df_pasteurization_mf_in.to_html(index=False))\n#HTML(df_pasteurization_mf_steam_gly.to_html(index=False))\n#HTML(df_pasteurization_heat_capacities.to_html(index=False))\n\n\n\n\n2.1.3.11 Results\n\n\nCode\n\nimport pandas as pd\nimport numpy as np\nfrom IPython.display import display, HTML\n\ndef degree(x):\n    return x +273.15\n\ndef to_J(x):\n    return x *1000\n\ndf_1_variable = pd.DataFrame(data = {'Variable' : ['Q_refrigeration','Q_past1','Q_past2','Q_past3','Q_past4','Q_past5','Q_past6','Q_past7']})\ndf_1_values = df_pasteurization_heat_flow['Value'].apply(to_J)\ndf_1 = pd.concat([df_1_variable,df_1_values], axis = 1)\n\ndf_2_variable = pd.DataFrame(data = {'Variable' : ['T_a','T_fmilk','T_mixure_out','T_past_cent','T_milk_0','T_cream_0','T_past_a','T_past_b','T_past_c','T_past_d','T_milk','T_crpast_a','T_thick','T_crpast_x','T_crpast_b','T_crpast_c','T_cream','T_steam_in','T_steam_out','T_glywater_in','T_glywater_out']})\ndf_2_values = df_pasteurization_temperatures['Value'].apply(degree)\ndf_2 = pd.concat([df_2_variable,df_2_values], axis = 1)\n\ndf_3_variable = pd.DataFrame(data = {'Variable' : ['m_fmilk','m_milk','m_cream','m_int','m_thick']})\ndf_3_values = df_pasteurization_mf_in['Value']\ndf_3 = pd.concat([df_3_variable,df_3_values], axis = 1)\n\ndf_4_variable = pd.DataFrame(data = {'Variable' : ['m_gly_ref','m_steam_past3','m_gly_past4','m_steam_past6','m_gly_past7']})\ndf_4_values = df_pasteurization_mf_steam_gly['Value']\ndf_4 = pd.concat([df_4_variable,df_4_values], axis = 1)\n\ndf_5_variable = pd.DataFrame(data = {'Variable' : ['Cp_alboline','Cp_raw_milk','Cp_cream','Cp_glywater','Cp_steam','Cp_fmilk','Cp_cream_mixed']})\ndf_5_values = df_pasteurization_heat_capacities['Value']\ndf_5 = pd.concat([df_5_variable,df_5_values], axis = 1)\n\ndf_6_variable =  pd.DataFrame(data = {'Variable' : ['delta_s_steam']})\ndf_6_values = df_pasteurization_entropy['Value']\ndf_6 = pd.concat([df_6_variable,df_6_values], axis = 1)\n\ndf_7_variable =  pd.DataFrame(data = {'Variable' : ['delta_h_steam']})\ndf_7_values = df_pasteurization_enthalpy['Value']\ndf_7 = pd.concat([df_7_variable,df_7_values], axis = 1)\n\n\ndf_pasteurization_csv = pd.concat([df_1,df_2,df_3,df_4,df_5,df_6,df_7], axis = 0, ignore_index = True)\n#df_pasteurization_csv = pd.concat([df_1,df_2,df_3,df_4,df_5], axis = 0, ignore_index = True)\n\ndf_pasteurization_csv.to_csv('pasteurization_process.csv',sep=';')\n\n\n\n\nCode\nimport pandas as pd\nimport numpy as np\nfrom IPython.display import display, HTML\n\ndf_pasteurization_heat_flow = df_pasteurization_heat_flow.round(2)\ndf_pasteurization_temperatures = df_pasteurization_temperatures.round(2)\ndf_pasteurization_mf_steam_gly = df_pasteurization_mf_steam_gly.round(2)\ndf_pasteurization_heat_capacities = df_pasteurization_heat_capacities.round(2)\n\nHTML(df_pasteurization_heat_flow.to_html(index=False))\n\n\n\n\n\nHeat Flow\nValue\nUnit\n\n\n\n\nRefrigeration\n60.42\nkJ/s\n\n\nPast1\n1691.65\nkJ/s\n\n\nPast2\n142.88\nkJ/s\n\n\nPast3\n285.76\nkJ/s\n\n\nPast4\n480.13\nkJ/s\n\n\nPast5\n17.52\nkJ/s\n\n\nPast6\n35.61\nkJ/s\n\n\nPast7\n146.24\nkJ/s\n\n\n\n\n\nCode\nHTML(df_pasteurization_temperatures.to_html(index=False))\n\n\n\n\n\nTemperature\nValue\nUnit\n\n\n\n\na\n24.85\n°C\n\n\nfmilk\n6.00\n°C\n\n\nmixure_out\n4.00\n°C\n\n\npast_cent\n60.00\n°C\n\n\nmilk_0\n60.00\n°C\n\n\ncream_0\n60.00\n°C\n\n\npast_a\n65.00\n°C\n\n\npast_b\n75.00\n°C\n\n\npast_c\n80.00\n°C\n\n\npast_d\n20.80\n°C\n\n\nmilk\n4.00\n°C\n\n\ncrpast_a\n65.90\n°C\n\n\nthick\n4.00\n°C\n\n\ncrpast_x\n56.49\n°C\n\n\ncrpast_b\n75.00\n°C\n\n\ncrpast_c\n80.00\n°C\n\n\ncream\n4.00\n°C\n\n\nsteam_in\n207.34\n°C\n\n\nsteam_out\n110.00\n°C\n\n\nglywater_in\n-5.00\n°C\n\n\nglywater_out\n-1.00\n°C\n\n\n\n\n\nCode\nHTML(df_pasteurization_mf_in.to_html(index=False))\n\n\n\n\n\nMass Flow\nValue\nUnit\n\n\n\n\nfresh_milk\n8.00\nkg/s\n\n\nmilk\n7.52\nkg/s\n\n\ncream\n0.55\nkg/s\n\n\nintern = fresh_milk - milk\n0.48\nkg/s\n\n\nthickener\n0.07\nkg/s\n\n\n\n\n\nCode\nHTML(df_pasteurization_mf_steam_gly.to_html(index=False))\n\n\n\n\n\nMass Flow\nValue\nUnit\n\n\n\n\nglywater in refrigeration\n3.87\nkg/s\n\n\nsteam in past3\n1.47\nkg/s\n\n\nglywater in past4\n30.78\nkg/s\n\n\nsteam in past6\n0.18\nkg/s\n\n\nglywater in past4\n9.37\nkg/s\n\n\n\n\n\nCode\nHTML(df_pasteurization_heat_capacities.to_html(index=False))\n\n\n\n\n\nHeat Capacity\nValue\nUnit\n\n\n\n\nalboline\n4175.00\nJ/(kg.K)\n\n\nraw_milk\n3800.00\nJ/(kg.K)\n\n\ncream\n3400.00\nJ/(kg.K)\n\n\nglywater\n3900.00\nJ/(kg.K)\n\n\nsteam\n1996.00\nJ/(kg.K)\n\n\nfmilk\n3776.00\nJ/(kg.K)\n\n\ncream_mixed\n3498.64\nJ/(kg.K)"
  },
  {
    "objectID": "02.00-process_description.html#evaporation",
    "href": "02.00-process_description.html#evaporation",
    "title": "2  Process description and analysis",
    "section": "2.2 Evaporation",
    "text": "2.2 Evaporation\n\n\n\nEvaporation\n\n\nThe evaporator section receives milk from pasteurisation. This milk can be seen as a mixture of water and fat. The aim of this section is to increase the fat proportion from 11.7\\% wt. to 50\\% wt. by evaporating water. It is composed of heat-exchanger (HEX), 3 evaporators, 2 splitters and a processing module.\nIn order to compute the mass and energy balance at each point, the following method is used:\n\nCompute the target mixture at the input and output of each evaporator, and the mass flow associated.\nCompute the heating demand of each evaporator and the mass flow of steam needed.\nDerive the mass flow of steam going from the evaporator, through the splitter, to the heat exchanger.\nCompute the heating capacity of each HEX and find the possible temperature steps according to the HEX requirements.\nCompute the Glycolic water needed to cool down the milk and the waste water from HEX.\nDerive the amount of whey that can be extracted from the processing module.\n\n\n2.2.1 Mixture at each Evaporator\nThe mass flow m_1 is a given data and the mass flows m_{14}, m_{15} and m_{16} are parameters that can be manually changed in order to get a reasonable system. Knowing those 4 mass flows and the target mixture, the fat content at each point can be computed by substracting water mass flows.\nGiven data:\n\nm_1 = 5.0 kg/s\nAt point 11, Fat content = 50\\%wt. and Water content = 50\\%wt.\n\nAssumptions:\n\nm_{14} = 1.6 kg/s\nm_{15} = 1.28 kg/s\nm_{16} = 0.8 kg/s\n\n\n\nCode\nimport pandas as pd\nimport numpy as np\nfrom IPython.display import display, HTML\n\nm1=5.0\nm6=m1\nm14=1.6\nm15=1.28\nm16=0.8\n\ndef fat_increase(m_int1, m_int2, m_int3, m_in = 5.0, p_fat_out3 = 0.50):\n    m_out = m_in - m_int1 - m_int2 - m_int3\n    if m_out &lt; 0:\n        print(\"ERROR: The mass of the output is negative.\")\n    # OUT 3\n    p_water_out3 = 1 - p_fat_out3\n    m_water_out3 = m_out * p_water_out3\n    m_fat = m_out * p_fat_out3\n    # OUT 2\n    m_water_out2 = m_water_out3 + m_int3\n    m_tot_2 = m_water_out2 + m_fat\n    p_fat_out2 = m_fat / m_tot_2\n    p_water_out2 = 1 - p_fat_out2\n    # OUT 1\n    m_water_out1 = m_water_out2 + m_int2\n    m_tot_1 = m_water_out1 + m_fat\n    p_fat_out1 = m_fat / m_tot_1\n    p_water_out1 = 1 - p_fat_out1\n    # OUT 0\n    m_water_out0 = m_water_out1 + m_int1\n    m_tot_0 = m_water_out0 + m_fat\n    p_fat_out0 = m_fat / m_tot_0\n    p_water_out0 = 1 - p_fat_out0\n    if p_water_out0 &gt; 0.883:\n        print(\"WARNING: The water content in the final product is too high.\")\n    return m_out, p_fat_out0, p_fat_out1, p_fat_out2, p_fat_out3, p_water_out0, p_water_out1, p_water_out2, p_water_out3\n\nm11, p_fat_out0, p_fat_out1, p_fat_out2, p_fat_out3, p_water_out0, p_water_out1, p_water_out2, p_water_out3 = fat_increase(m_int1=m14, m_int2=m15, m_int3=m16, m_in = m6, p_fat_out3 = 0.5)\n\ndata = {'Point': ['6', '7&8', '9&10', '11'],\n        'Fat content (%)': [p_fat_out0*100, p_fat_out1*100, p_fat_out2*100, p_fat_out3*100],\n        'Water content (%)': [p_water_out0*100, p_water_out1*100, p_water_out2*100, p_water_out3*100]}\ndf = pd.DataFrame(data)\ndf = df.set_index('Point')\ndf = df.round(2)\n#print(df)\nHTML(df.to_html())\n\n\n\n\n\n\nFat content (%)\nWater content (%)\n\n\nPoint\n\n\n\n\n\n\n6\n13.20\n86.80\n\n\n7&8\n19.41\n80.59\n\n\n9&10\n31.13\n68.87\n\n\n11\n50.00\n50.00\n\n\n\n\n\n\n\n2.2.2 Heating Demand and Steam Flow of Evaporators\nKnowing the mass flow of each evaporator, the heating demand can be computed. The heating demand is the amount of heat needed to evaporate the water in the milk and is given by the following equation.\n\nQ_{\\text{evap}} = m_{\\text{in}} \\cdot c_{p_{\\text{in}}} \\cdot \\Delta T - m_{\\text{in}} \\cdot h_{\\text{in}} + m_{\\text{out1}} \\cdot h_{\\text{out1}} + m_{\\text{out2}} \\cdot h_{\\text{out2}}\n\\tag{2.11}\nThen, knowing the heat requirement, it is possible to derive the mass flow of steam that is needed to evaporate the water, assuming a pressure value.\n\nm_{\\text{w}} = \\frac{Q_{\\text{evap}}}{h_{\\text{fg}}}\n\\tag{2.12}\nAll the enthalpy, heat capacity and latent heat of vaporization are computed using the CoolProp library. The pressure of the steam is assumed.\nGiven/Known data:\n\nAll the mixture mass flows, pressures and temperatures (either given or computed on previous section)\n\nAssumptions:\n\nSteam at point 22 is assumed to be 1 bar, at 373 K (saturated steam)\nPerfect evaporator\n\n\n\nCode\n#Evaporator 1\nfrom codes_01_energy_bill.coolprop_functions import mixture\nfrom pyxosmose.state import State\ndef evaporator_fct(m_in,m_out1,m_out2,h_in,h_out1,h_out2,cp_in,deltaT,hfg):\n    Q_evap = m_in*cp_in*deltaT - m_in*h_in + m_out1*h_out1 + m_out2*h_out2\n    m_w = (Q_evap)/(hfg)\n    #print('Qevap:',Q_evap)\n    #print('mw:',m_w)\n    return Q_evap, m_w\n#Fixed Parameters \np6=31000\np7=p6\np14=p6\np24=100000\n\nT6=343\nT7=T6\nT14=343\nT24=373 #can be changed if needed to reduce cost instead of having a high pressure\n\n#Dependent Parameters\nState_e6=mixture(T=T6, P=p6, frac_water=p_water_out0, frac_fat=p_fat_out0) # this is a dictionary!!\n#print(State_e6)\nh6=State_e6[\"enthalpy\"]\ncp6=State_e6[\"cpmass\"]\n\nState_e7=mixture(T=T7, P=p7, frac_water=p_water_out1, frac_fat=p_fat_out1) # this is a dictionary!!\n#print(State_e7)\nh7=State_e7[\"enthalpy\"]\n\nPoint_e14 = State(pair='TP', fluid='water', temperature=T14, pressure=p14)\n# Then calculate the state using the State class method StateCalc\nPoint_e14.StateCalc()\n# And print the dictionary for revision\nState_e14 = Point_e14.__dict__ # Whole dictionary with properties\nh14=State_e14[\"enthalpy\"]\n#print(h14)\n\nPoint_e24 = State(pair='TP', fluid='water', temperature=T24, pressure=p24)\n# Then calculate the state using the State class method StateCalc\nPoint_e24.StateCalc()\n# And print the dictionary for revision\nState_e24 = Point_e24.__dict__ # Whole dictionary with properties\nhfg1=State_e24[\"enthalpy\"]\n#print(hfg1)\n\n#Evap 1 calculation of heat \nm7=m6-m14\ndeltaT=5\n\nQ_evap1, m_w1 = evaporator_fct(m6,m14,m7,h6,h14,h7,cp6,deltaT,hfg1)\n\n#print(Q_evap1)\n#print(m_w1)\n\n#Evaporator 2\n\nfrom codes_01_energy_bill.coolprop_functions import mixture\n\np8=25000\np9=p8\np15=25000\np17=p14\n\nT8=338\nT9=T8\nT15=338\nT17=T14\n\nState_e8=mixture(T=T8, P=p8, frac_water=p_water_out2, frac_fat=p_fat_out2) # this is a dictionary!!\n#print(State_e8)\nh8=State_e8[\"enthalpy\"]\ncp8=State_e8[\"cpmass\"]\n\nState_e9=mixture(T=T9, P=p9, frac_water=p_water_out2, frac_fat=p_fat_out2) # this is a dictionary!!\n#print(State_e9)\nh9=State_e9[\"enthalpy\"]\n\nPoint_e15 = State(pair='TP', fluid='water', temperature=T15, pressure=p15)\n# Then calculate the state using the State class method StateCalc\nPoint_e15.StateCalc()\n# And print the dictionary for revision\nState_e15 = Point_e15.__dict__ # Whole dictionary with properties\nh15=State_e15[\"enthalpy\"]\n#print(h15)\n\nPoint_e17 = State(pair='TP', fluid='water', temperature=T17, pressure=p17)\n# Then calculate the state using the State class method StateCalc\nPoint_e17.StateCalc()\n# And print the dictionary for revision\nState_e17 = Point_e17.__dict__ # Whole dictionary with properties\nhfg2=State_e17[\"enthalpy\"]\n#print(hfg2)\n\nm8=m7\nm9=m8-m15\ndeltaT=5\n\nQ_evap2, m_w2 = evaporator_fct(m8,m15,m9,h8,h15,h9,cp8,deltaT,hfg2)\n\n#print(Q_evap2)\n#print(m_w2)\n\n#Evaporator 3\n\nfrom codes_01_energy_bill.coolprop_functions import mixture\n\np10=20000\np11=p10\np15=25000\np18=p15\np16=20000\n\nT10=333\nT11=T10\nT15=338\nT18=T15\nT16=333\n\nState_e10=mixture(T=T10, P=p10, frac_water=p_water_out2, frac_fat=p_fat_out2) # this is a dictionary!!\n#print(State_e10)\nh10=State_e10[\"enthalpy\"]\ncp10=State_e10[\"cpmass\"]\n\nState_e11=mixture(T=T11, P=p11, frac_water=p_water_out3, frac_fat=p_fat_out3) # this is a dictionary!!\n#print(State_e11)\nh11=State_e11[\"enthalpy\"]\n\nPoint_e16 = State(pair='TP', fluid='water', temperature=T16, pressure=p16)\n# Then calculate the state using the State class method StateCalc\nPoint_e16.StateCalc()\n# And print the dictionary for revision\nState_e16 = Point_e16.__dict__ # Whole dictionary with properties\nh16=State_e16[\"enthalpy\"]\n#print(h16)\n\nPoint_e18 = State(pair='TP', fluid='water', temperature=T18, pressure=p18)\n# Then calculate the state using the State class method StateCalc\nPoint_e18.StateCalc()\n# And print the dictionary for revision\nState_e18 = Point_e18.__dict__ # Whole dictionary with properties\nhfg3=State_e18[\"enthalpy\"]\n#print(hfg3)\n\nm10=m9\nm11=m10-m16\ndeltaT=5\n\nQ_evap3, m_w3 = evaporator_fct(m10,m16,m11,h10,h16,h11,cp10,deltaT,hfg3)\n\nm17=m_w2\nm18=m_w3\nm24=m_w1\n\n#print(Q_evap3)\n#print(m_w3)\n# print mass flow, temperature, preasure for the points 6, 7, 8, 9, 10, 11, 14, 15, 16, 17, 18 in a dataframe\n\ndata = {'Point': ['6', '7', '8', '9', '10', '11', '14', '15', '16', '17', '18', '24'],\n        'Mass flow (kg/s)': [m6, m7, m8, m9, m10, m11, m14, m15, m16, m17, m18, m24],\n        'Temperature (K)': [T6, T7, T8, T9, T10, T11, T14, T15, T16, T17, T18, T24],\n        'Pressure (Pa)': [p6, p7, p8, p9, p10, p11, p14, p15, p16, p17, p18, p24]}\ndf = pd.DataFrame(data)\ndf = df.set_index('Point')\ndf = df.round(4)\nHTML(df.to_html())\n\n\n\n\n\n\nMass flow (kg/s)\nTemperature (K)\nPressure (Pa)\n\n\nPoint\n\n\n\n\n\n\n\n6\n5.0000\n343\n31000\n\n\n7\n3.4000\n343\n31000\n\n\n8\n3.4000\n338\n25000\n\n\n9\n2.1200\n338\n25000\n\n\n10\n2.1200\n333\n20000\n\n\n11\n1.3200\n333\n20000\n\n\n14\n1.6000\n343\n31000\n\n\n15\n1.2800\n338\n25000\n\n\n16\n0.8000\n333\n20000\n\n\n17\n1.5505\n343\n31000\n\n\n18\n0.1386\n338\n25000\n\n\n24\n0.0366\n373\n100000\n\n\n\n\n\nCode\n#print in a data frame the heat demand of each evaporator\ndata = {'Evaporator': ['1', '2', '3'],\n        'Heat demand (W)': [Q_evap1, Q_evap2, Q_evap3]}\ndf = pd.DataFrame(data)\ndf = df.set_index('Evaporator')\ndf = df.round(4)\nHTML(df.to_html())\n\n\n\n\n\n\nHeat demand (W)\n\n\nEvaporator\n\n\n\n\n\n1\n98038.8718\n\n\n2\n453437.0884\n\n\n3\n37624.9694\n\n\n\n\n\n\n\n2.2.3 Steam Flow to HEX\nFrom previous sections, m_{14}, m_{15}, m_{16}, m_{17}, and m_{18} are known. The mass flow of steam going through the HEX4, HEX3 can be computed using the following equation, corresponding to the ideal splitter:\n\nm_{\\text{steam,HEX}} = m_{\\text{in}} - m_{\\text{steam,evap}}\n\\tag{2.13}\nThe steam mass flow through HEX2 and HEX1 are known ; m_{16} and m_{11} respectively.\nKnown data:\n\nm_{14}, m_{15}, m_{16}, m_{17}, and m_{18}\n\nAssumptions:\n\nPerfect splitter\n\n\n\nCode\nm19=m14-m_w2\nm20=m15-m_w3\n#print(' mHEX4 = m19 = ', m19, '\\n', 'mHEX3 = m20 = ', m20, '\\n', 'mHEX2 = m16 = ', m16, '\\n', 'mHEX1 = m11 = ', m11, '\\n',)\nprint(f'mHEX4 = m19 = {m19:.3f} (kg/s)\\n'\n      f'mHEX3 = m20 = {m20:.3f} (kg/s)\\n'\n      f'mHEX2 = m16 = {m16:.3f} (kg/s)\\n'\n      f'mHEX1 = m11 = {m11:.3f} (kg/s)\\n')\n\n\nmHEX4 = m19 = 0.049 (kg/s)\nmHEX3 = m20 = 1.141 (kg/s)\nmHEX2 = m16 = 0.800 (kg/s)\nmHEX1 = m11 = 1.320 (kg/s)\n\n\n\n\n2.2.4 HEX Heat Demand and Temperature Steps\nBefore doing any calculation, it is noticeable that m_{19}, i.e. the hot flow through HEX4, is very small. The heating capacity is therefore too small to ensure the required heating. In order to reduce the cost of the system, it is preferable to remove HEX4. To compute the temperature steps and the heating capacity, the following method is used:\n\nAssume some temperature steps between the 3 HEX.\nCompute the heating capacity of each HEX, by being aware that T_{\\text{hot,out}} \\geq T_{\\text{cold,in}} condition is satisfied.\nAdapt the temperature steps with the heating capacity of each HEX, to satisfy the previous condition.\n\nThe following function is used to know the heating capacity of each HEX:\ndef HeatExchanger(mcold, cpcold, Tcoldin, Tcoldout, Thotin, cphot, mhot, hhot):\n    Q = mcold * cpcold * (Tcoldout - Tcoldin)\n    Qcond = mhot * abs(hhot)\n    if Qcond &lt; Q:\n        #print(\"Cold stream is completely condensed\")\n        Thotout = (-Q + mhot * abs(hhot)) / (mhot * cphot) + Thotin\n    else:\n        #print(\"Cold stream is not completely condensed\")\n        Thotout = Thotin\n    return Q, Thotout\n\n\nCode\ndef HeatExchanger(mcold, cpcold, Tcoldin, Tcoldout, Thotin, cphot, mhot, hhot):\n    Q = mcold*cpcold*(Tcoldout-Tcoldin)\n    Qcond = mhot*abs(hhot)\n    if Qcond&lt;Q:\n        #print(\"Cold stream is completely condensed\")\n        Thotout = (-Q+mhot*abs(hhot))/(mhot*cphot) + Thotin\n    else:\n        #print(\"Cold stream is not completely condensed\")\n        Thotout = Thotin\n    #print('Q_cond:', Qcond, 'W')\n    #print('Q_HEX:', Q, 'W')\n    #print('T_cold_in:', Tcoldin, 'K')\n    #print('T_cold_out:', Tcoldout, 'K')\n    #print('T_hot_in:', Thotin, 'K')\n    #print('T_hot_out:', Thotout, 'K')\n    return Q, Thotout\n\n# Heat Exchanger 4\n# Calculation can be done but the module is not used\n\nT4=338\nT5=T4\nT19=T14\np4=100000\nState_e4=mixture(T=T4, P=p4, frac_water=p_water_out0, frac_fat=p_fat_out0) # this is a dictionary!!\ncp4=State_e4[\"cpmass\"]\nm5=m1\nm19=m14-m_w2\np19=p6\nPoint_e19 = State(pair='TP', fluid='water', temperature=T19, pressure=p19)\n# Then calculate the state using the State class method StateCalc\nPoint_e19.StateCalc()\n# And print the dictionary for revision\nState_e19 = Point_e19.__dict__ # Whole dictionary with properties\nh19=State_e19[\"enthalpy\"]\ncp19=State_e19[\"cpmass\"]\n\nQ4, Thot4 = HeatExchanger(m5, cp4, T4, T5, T19, cp19, m19, h19)\n\n#Heat Exchanger 3\nT3=317.5\nT20=T15\nm4=m1\nm20=m15-m_w3\np20=p8\np3=p4\nState_e3=mixture(T=T3, P=p3, frac_water=p_water_out0, frac_fat=p_fat_out0) # this is a dictionary!!\ncp3=State_e3[\"cpmass\"]\n\nPoint_e20 = State(pair='TP', fluid='water', temperature=T20, pressure=p20)\n# Then calculate the state using the State class method StateCalc\nPoint_e20.StateCalc()\n# And print the dictionary for revision\nState_e20 = Point_e20.__dict__ # Whole dictionary with properties\nh20=State_e20[\"enthalpy\"]\ncp20=State_e20[\"cpmass\"]\n\nQ3, Thot3 = HeatExchanger(m4, cp3, T3, T4, T20, cp20, m20, h20)\n\n#Heat Exchanger 2\nT2=302\nm3=m1\np2=p4\nState_e2=mixture(T=T2, P=p2, frac_water=p_water_out0, frac_fat=p_fat_out0) # this is a dictionary!!\ncp2=State_e2[\"cpmass\"]\ncp16=State_e16[\"cpmass\"]\n\nQ2, Thot2 = HeatExchanger(m3, cp2, T2, T3, T16, cp16, m16, h16)\n\n#Heat Exchanger 1\nT1=277\np1=p4\nState_e1=mixture(T=T1, P=p1, frac_water=p_water_out0, frac_fat=p_fat_out0) # this is a dictionary!!\ncp1=State_e1[\"cpmass\"]\ncp11=State_e11[\"cpmass\"]\nh11=State_e11[\"enthalpy\"]\n\n# mcold, cpcold, Tcoldin, Tcoldout, Thotin, cphot, mhot, hhot\nQ1, Thot1 = HeatExchanger(m1, cp1, T1, T2, T11, cp11, m11, h11)\n\n#HeatExchanger(mcold, cpcold, Tcoldin, Tcoldout, Thotin, cphot, mhot, hhot)\n#Q4, Thot4 = HeatExchanger(m5, cp4, T4, T5, T19, cp19, m19, h19)\n#Q3, Thot3 = HeatExchanger(m4, cp3, T3, T4, T20, cp20, m20, h20)\n#Q2, Thot2 = HeatExchanger(m3, cp2, T2, T3, T16, cp16, m16, h16)\n#Q1, Thot1 = HeatExchanger(m1, cp1, T1, T2, T11, cp11, m11, h11)\n\ndata = {'HEX': ['1', '2', '3', '4'],\n        'Steam Flow (kg/s)' : [m11, m16, m20, m19],\n        'T cold in (K)': [T1, T2, T3, T4],\n        'T cold out (K)': [T2, T3, T4, T5],\n        'T hot in (K)': [T11, T16, T20, T19],\n        'T hot out (K)': [Thot1, Thot2, Thot3, Thot4],\n        'Heat (W)': [Q1, Q2, Q3, Q4]}\ndf = pd.DataFrame(data)\ndf = df.set_index('HEX')\ndf = df.round(2)\nHTML(df.to_html())\n\n\n\n\n\n\nSteam Flow (kg/s)\nT cold in (K)\nT cold out (K)\nT hot in (K)\nT hot out (K)\nHeat (W)\n\n\nHEX\n\n\n\n\n\n\n\n\n\n\n1\n1.32\n277.0\n302.0\n333\n290.39\n491475.77\n\n\n2\n0.80\n302.0\n317.5\n333\n302.41\n302869.43\n\n\n3\n1.14\n317.5\n338.0\n338\n319.00\n400698.49\n\n\n4\n0.05\n338.0\n338.0\n343\n343.00\n0.00\n\n\n\n\n\n\n\n2.2.5 Cooling Demand\nHEX5 ensures that the milk is cooled down from T_{\\text{hot,out,HEX1}} = 290.38 K to 277 K. The cooling demand is computed using the following equation:\n\nQ_{\\text{glycol}} = m_{12} \\cdot cp_{12} \\cdot (T_{12} - T_{13})\n\\tag{2.14}\n\nm_{\\text{glycol}} = \\frac{Q_{\\text{glycol}}}{cp_{{\\text{glycol}}} \\cdot (T_{\\text{out,glycol}} - T_{\\text{in,glycol}})}\n\\tag{2.15}\nGiven/Known data:\n\nm_{12}, T_{12}, T_{13}\n\nAssumptions:\n\nT_{\\text{in,glycol}} = 270 K\nT_{\\text{out,glycol}} = 277 K\ncp_{\\text{glycol}} = 2294 kJ/kg.K\n\n\n\nCode\n#Heat Exchanger Glycolic water\n\np12=p11\nT12=Thot1\nT13=277\nm12=m11\n#print(p12,p_water_out3,p_fat_out3)\nState_e12 = mixture(T=T12, P=p12, frac_water=p_water_out3, frac_fat=p_fat_out3)\ncp12=State_e12[\"cpmass\"]\n#print('cp12', cp12)\n\n\nTinglycol=270\nToutglycol=277\ncpglycol=2294\n\nQglycol = m12*cp12*(T12-T13)\nmglycol = m12*(cp12/cpglycol)*(T12-T13)/(Toutglycol-Tinglycol)\n\nprint(f'Q_glycol = {Qglycol:.3f} (W)\\n'\n      f'm_glycol = {mglycol:.3f} (kg/s)')\n\n\nQ_glycol = 55703.141 (W)\nm_glycol = 3.469 (kg/s)\n\n\n\n\n2.2.6 Whey Extraction\nFinally, in order to match the target fat content, it is possible to extract whey from the system. The mass flow of whey is computed using the following equation:\nProcessing:\nFlow In: \\begin{align*}\n    m_{\\text{pasteur}} &= 7.52 \\text{ (kg/s)}\\\\\n    p_{\\text{water\\_pasteur}} &= 0.883 \\\\\n    p_{\\text{fat\\_pasteur}} &= 1 - p_{\\text{water\\_pasteur}}\n\\end{align*}\nFlow to HEX:\n\\begin{align*}\n    m_1 &= 5.0 \\text{ (kg/s)}\\\\\n    p_{\\text{water\\_out1}} &= 0.868 \\\\\n    p_{\\text{fat\\_out1}} &= 1 - p_{\\text{water\\_out1}}\n\\end{align*}\nFlow to Filter: \\begin{align*}\n    m_{\\text{water\\_21}} &= m_{\\text{pasteur}} \\cdot p_{\\text{water\\_pasteur}} - p_{\\text{water\\_out1}} \\cdot m_1 \\\\\n    m_{\\text{fat\\_21}} &= m_{\\text{pasteur}} \\cdot p_{\\text{fat\\_pasteur}} - p_{\\text{fat\\_out1}} \\cdot m_1 \\\\\n    m_{21} &= m_{\\text{pasteur}} - m_1 \\\\\n    p_{\\text{water\\_21}} &= \\frac{m_{\\text{water\\_21}}}{m_{21}} \\\\\n    p_{\\text{fat\\_21}} &= \\frac{m_{\\text{fat\\_21}}}{m_{21}}\n\\end{align*}\nFilter:\nWastewater flow:\n\\begin{align*}\n    m_{23} &= 1 \\text{ (kg/s)}\\\\\n    p_{\\text{water\\_23}} &= 1 \\\\\n    p_{\\text{fat\\_23}} &= 0\n\\end{align*}\nWhey flow: \\begin{align*}\n    m_{\\text{water\\_22}} &= m_{\\text{water\\_21}} - m_{23} \\cdot p_{\\text{water\\_23}} \\\\\n    m_{\\text{fat\\_22}} &= m_{\\text{fat\\_21}} - m_{23} \\cdot p_{\\text{fat\\_23}} \\\\\n    m_{22} &= m_{21} - m_{23} \\\\\n    p_{\\text{water\\_22}} &= \\frac{m_{\\text{water\\_22}}}{m_{22}} \\\\\n    p_{\\text{fat\\_22}} &= \\frac{m_{\\text{fat\\_22}}}{m_{22}}\n\\end{align*}\n\n\nCode\n# Processing\n# Flow In\nm_pasteur = 7.52\np_water_pasteur = 0.883\np_fat_pasteur = 1 - p_water_pasteur\n\n# Flow Out\nm_water_21 = m_pasteur * p_water_pasteur - p_water_out0 * m1\nm_fat_21 = m_pasteur * p_fat_pasteur - p_fat_out0 * m1\n\nm_21 = m_pasteur - m1\np_water_21 = m_water_21 / m_21\np_fat_21 = m_fat_21 / m_21\n\n# Filter\nm_23 = 1\np_water_23 = 1\np_fat_23 = 0\n\n# Flow out Whey\nm_water_22 = m_water_21 - m_23 * p_water_23\nm_fat_22 = m_fat_21 - m_23 * p_fat_23\n\nm_22 = m_21 - m_23\np_water_22 = m_water_22 / m_22\np_fat_22 = m_fat_22 / m_22\n\n# Print in a data frame the percent and mass flow of fat and water for point pasteur, 21, 22 and 23\ndata = {'Point': ['Pasteur', '21', '22', '23'],\n        'Fat content (%)': [p_fat_pasteur*100, p_fat_21*100, p_fat_22*100, p_fat_23*100],\n        'Water content (%)': [p_water_pasteur*100, p_water_21*100, p_water_22*100, p_water_23*100],\n        'Mass flow (kg/s)': [m_pasteur, m_21, m_22, m_23]}\ndfwhey = pd.DataFrame(data)\ndfwhey = dfwhey.set_index('Point')\ndfwhey = dfwhey.round(2)\n#print(dfwhey)\nHTML(dfwhey.to_html())\n\n\n\n\n\n\nFat content (%)\nWater content (%)\nMass flow (kg/s)\n\n\nPoint\n\n\n\n\n\n\n\nPasteur\n11.70\n88.30\n7.52\n\n\n21\n8.72\n91.28\n2.52\n\n\n22\n14.46\n85.54\n1.52\n\n\n23\n0.00\n100.00\n1.00\n\n\n\n\n\n\n\n2.2.7 Summary for the evaporator section\n\n\nCode\n#Entropy\n\n#Computing remaining states\np5=p4\nState_e5 = mixture(T=T5, P=p5, frac_water=p_water_out0, frac_fat=p_fat_out0) # this is a dictionary!!\n\np13=p12\nState_e13 = mixture(T=T13, P=p13, frac_water=p_water_out3, frac_fat=p_fat_out3) # this is a dictionary!!\n\nT21=277\np21=p1\nState_e21 = mixture(T=T21, P=p21, frac_water=p_water_21, frac_fat=p_fat_21) # this is a dictionary!!\n\nT22=T21\np22=p21\nState_e22 = mixture(T=T22, P=p22, frac_water=p_water_22, frac_fat=p_fat_22) # this is a dictionary!!\n\nT23=T21\np23=p21\nState_e23 = mixture(T=T23, P=p23, frac_water=p_water_23, frac_fat=p_fat_23) # this is a dictionary!!\n\n\nTtest2=T16\nptest2=p16\nState_test2 = State(pair='TP', fluid='water', temperature=Ttest2, pressure=ptest2) \nState_test2.StateCalc()\n# And print the dictionary for revision\nState_test2 = State_test2.__dict__\n\nTtest3=T20\nptest3=p20\nState_test3 = State(pair='TP', fluid='water', temperature=Ttest3, pressure=ptest3) \nState_test3.StateCalc()\n# And print the dictionary for revision\nState_test3 = State_test3.__dict__\n\nTtest4=T19\nptest4=p19\nState_test4 = State(pair='TP', fluid='water', temperature=Ttest4, pressure=ptest4) \nState_test4.StateCalc()\n# And print the dictionary for revision\nState_test4 = State_test4.__dict__\n\n#Exctraction of entropy\ns1=State_e1[\"entropy\"]\ns2=State_e2[\"entropy\"]\ns3=State_e3[\"entropy\"]\ns4=State_e4[\"entropy\"]\ns5=State_e5[\"entropy\"]\ns6=State_e6[\"entropy\"]\ns7=State_e7[\"entropy\"]\ns8=State_e8[\"entropy\"]\ns9=State_e9[\"entropy\"]\ns10=State_e10[\"entropy\"]\ns11=State_e11[\"entropy\"]\ns12=State_e12[\"entropy\"]\ns13=State_e13[\"entropy\"]\ns14=State_e14[\"entropy\"]\ns15=State_e15[\"entropy\"]\ns16=State_e16[\"entropy\"]\ns17=State_e17[\"entropy\"]\ns18=State_e18[\"entropy\"]\ns19=State_e19[\"entropy\"]\ns20=State_e20[\"entropy\"]\ns21=State_e21[\"entropy\"]\ns22=State_e22[\"entropy\"]\ns23=State_e23[\"entropy\"]\nstest2=State_test2[\"entropy\"]\nstest3=State_test3[\"entropy\"]\nstest4=State_test4[\"entropy\"]\n\nh1=State_e1[\"enthalpy\"]\nh2=State_e2[\"enthalpy\"]\nh3=State_e3[\"enthalpy\"]\nh4=State_e4[\"enthalpy\"]\nh5=State_e5[\"enthalpy\"]\nh6=State_e6[\"enthalpy\"]\nh7=State_e7[\"enthalpy\"]\nh8=State_e8[\"enthalpy\"]\nh9=State_e9[\"enthalpy\"]\nh10=State_e10[\"enthalpy\"]\nh11=State_e11[\"enthalpy\"]\nh12=State_e12[\"enthalpy\"]\nh13=State_e13[\"enthalpy\"]\nh14=State_e14[\"enthalpy\"]\nh15=State_e15[\"enthalpy\"]\nh16=State_e16[\"enthalpy\"]\nh17=State_e17[\"enthalpy\"]\nh18=State_e18[\"enthalpy\"]\nh19=State_e19[\"enthalpy\"]\nh20=State_e20[\"enthalpy\"]\nh21=State_e21[\"enthalpy\"]\nh22=State_e22[\"enthalpy\"]\nh23=State_e23[\"enthalpy\"]\nhtest2=State_test2[\"enthalpy\"]\nhtest3=State_test3[\"enthalpy\"]\nhtest4=State_test4[\"enthalpy\"]\n\nm2=m1\nm13=m12\nm17=m_w2\nm18=m_w3\nm21 = m_21\nm22 = m_22\nm23 = m_23\nmtest2=m16\nmtest3=m20\nmtest4=m19\n\n#Recap\n#Print in a dataframe: Temperature, Pressure, Mass flow, Enthalpy, Entropy for each point (i.e. 1 to 23)\n\ndatarecap = {'Point': ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10','11', '12', '13', '14', '15', '16', '17', '18', '19', '20','21', '22', '23', 'test2', 'test3', 'test4'],\n        'Temperature (K)': [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,T11, T12, T13, T14, T15, T16, T17, T18, T19, T20,T21, T22, T23,Ttest2, Ttest3, Ttest4],\n        'Pressure (Pa)': [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,p11, p12, p13, p14, p15, p16, p17, p18, p19, p20,p21, p22, p23,ptest2, ptest3, ptest4],\n        'Mass flow (kg/s)': [m1, m2, m3, m4, m5, m6, m7, m8, m9, m10,m11, m12, m13, m14, m15, m16, m17, m18, m19, m20,m21, m22, m23,mtest2, mtest3, mtest4],\n        'Enthalpy (J/mol)': [h1, h2, h3, h4, h5, h6, h7, h8, h9, h10,h11, h12, h13, h14, h15, h16, h17, h18, h19, h20,h21, h22, h23,htest2, htest3, htest4],\n        'Entropy (J/K)': [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10,s11, s12, s13, s14, s15, s16, s17, s18, s19, s20,s21, s22, s23,stest2, stest3, stest4]}\ndfrecap = pd.DataFrame(datarecap)\ndfrecap = dfrecap.set_index('Point')\ndfrecap = dfrecap.round(2)\nHTML(dfrecap.to_html())\n\n\n\n\n\n\nTemperature (K)\nPressure (Pa)\nMass flow (kg/s)\nEnthalpy (J/mol)\nEntropy (J/K)\n\n\nPoint\n\n\n\n\n\n\n\n\n\n1\n277.00\n100000\n5.00\n-97330.56\n-203.15\n\n\n2\n302.00\n100000\n5.00\n560.64\n135.21\n\n\n3\n317.50\n100000\n5.00\n61136.10\n330.82\n\n\n4\n338.00\n100000\n5.00\n141356.45\n575.65\n\n\n5\n338.00\n100000\n5.00\n141356.45\n575.65\n\n\n6\n343.00\n31000\n5.00\n160898.84\n633.26\n\n\n7\n343.00\n31000\n3.40\n98998.76\n482.65\n\n\n8\n338.00\n25000\n3.40\n-35572.68\n146.29\n\n\n9\n338.00\n25000\n2.12\n-35572.68\n146.29\n\n\n10\n333.00\n20000\n2.12\n-53332.80\n93.37\n\n\n11\n333.00\n20000\n1.32\n-237505.80\n-352.72\n\n\n12\n290.39\n20000\n1.32\n-371880.45\n-784.48\n\n\n13\n277.00\n20000\n1.32\n-414140.10\n-933.47\n\n\n14\n343.00\n31000\n1.60\n292436.50\n953.30\n\n\n15\n338.00\n25000\n1.28\n271487.85\n891.79\n\n\n16\n333.00\n20000\n0.80\n250552.63\n829.41\n\n\n17\n343.00\n31000\n1.55\n292436.50\n953.30\n\n\n18\n338.00\n25000\n0.14\n271487.85\n891.79\n\n\n19\n343.00\n31000\n0.05\n292436.50\n953.30\n\n\n20\n338.00\n25000\n1.14\n271487.85\n891.79\n\n\n21\n277.00\n100000\n2.52\n-58804.20\n-114.31\n\n\n22\n277.00\n100000\n1.52\n-108202.50\n-228.22\n\n\n23\n277.00\n100000\n1.00\n16281.23\n58.82\n\n\ntest2\n333.00\n20000\n0.80\n250552.63\n829.41\n\n\ntest3\n338.00\n25000\n1.14\n271487.85\n891.79\n\n\ntest4\n343.00\n31000\n0.05\n292436.50\n953.30\n\n\n\n\n\nCode\n#Print in a dataframe: Q for each heat exchanger and evaporator\ndataevap = {'Evaporator': ['1', '2', '3'],\n        'Q (W)': [Q_evap1, Q_evap2, Q_evap3]}\ndfevap = pd.DataFrame(dataevap)\ndfevap = dfevap.set_index('Evaporator')\ndfevap = dfevap.round(2)\nHTML(dfevap.to_html())\n\n\n\n\n\n\nQ (W)\n\n\nEvaporator\n\n\n\n\n\n1\n98038.87\n\n\n2\n453437.09\n\n\n3\n37624.97\n\n\n\n\n\nCode\n#Print in a dataframe: Q for each heat exchanger and evaporator\ndatahx = {'Heat_Exchanger': ['1', '2', '3', '4', 'Glycolic'],\n        'Q (W)': [Q1, Q2, Q3, Q4, Qglycol]}\ndfhx = pd.DataFrame(datahx)\ndfhx = dfhx.set_index('Heat_Exchanger')\ndfhx = dfhx.round(2)\nHTML(dfhx.to_html())\n\n\n\n\n\n\nQ (W)\n\n\nHeat_Exchanger\n\n\n\n\n\n1\n491475.77\n\n\n2\n302869.43\n\n\n3\n400698.49\n\n\n4\n0.00\n\n\nGlycolic\n55703.14\n\n\n\n\n\n\n\nCode\n#Load the dataframe in a csv file\n\ndfrecap.to_csv('dfrecap.csv')\ndfevap.to_csv('dfevap.csv')\ndfhx.to_csv('dfhx.csv')"
  },
  {
    "objectID": "02.00-process_description.html#drum-dryers",
    "href": "02.00-process_description.html#drum-dryers",
    "title": "2  Process description and analysis",
    "section": "2.3 Drum Dryers",
    "text": "2.3 Drum Dryers\n\n\n\nDrum Dryers\n\n\nThis section will present the mass and energy balances of the various steps involved in the process of drying the concentrated milk into milk powder. The concentrated milk is received by the evaporation section. As such the concentrated milk is considered to be a mixture of 50% water and 50% fat which will be transformed into a mixture of 96% fat and 4% water.\nThis section consists of multiple step:\n\nCompute the mixture proportions at the input and output of each dryer.\nCompute the heating demand of each dryer\nCompute the heating demand of each HEX component\nCompute the amount of cooling water needed to cool down the milk powder\nCompute the amount of steam needed to heat up the humid air\nCompute the amount of water exiting the system at dd13\n\n\n2.3.1 Mixture at each dryer\nThe parameters of the mixture at the position dd1 is known, since it is the same mixture exiting the evaporation process. Knowing that the second dryer evaporates 63% of the water it receives as input, it is possible to compute the proportions of water and fat content at each input and output of the dryers.\n\n\nCode\nmass_dd1 = 1.32\n#mass_dd5 = 0.5*mass_dd4 + 0.5*mass_dd4*(1-0.63) = mass_dd1*0.5 + mass_dd1*0.08\n#mass_dd5 = mass_dd1*0.5 + mass_dd1*0.5*0.04\n#96% = 0.5*mass_dd1\n\nmass_dd5 = 0.5*mass_dd1 + (0.5*mass_dd1/0.96)*0.04\nmass_dd4 = mass_dd5/(0.5+0.5*(1-0.63))\nmass_dd4 = 0.5*mass_dd1 + (mass_dd5-0.5*mass_dd1)/0.37\n\nwater_dd1 = 50\nwater_dd4 = ((mass_dd4 - mass_dd1/2)/mass_dd4)*100\nwater_dd5 = ((mass_dd5 - mass_dd1/2)/mass_dd5)*100\n\ndata_m = {'Position': ['dd1', 'dd4', 'dd5', 'dd7'],\n        'm (kg)': [mass_dd1, mass_dd4, mass_dd5, mass_dd5],\n        'Water Proportion': [water_dd1, water_dd4, water_dd5, water_dd5]}\n\ndfm = pd.DataFrame(data_m)\ndfm = dfm.set_index('Position')\ndfm = dfm.round(2)\nHTML(dfm.to_html())\n\n\n\n\n\n\nm (kg)\nWater Proportion\n\n\nPosition\n\n\n\n\n\n\ndd1\n1.32\n50.00\n\n\ndd4\n0.73\n10.12\n\n\ndd5\n0.69\n4.00\n\n\ndd7\n0.69\n4.00\n\n\n\n\n\n\n\n2.3.2 Heating demand of each dryer\nFor this part of the calculations it is assumed that the temperature of the steam at the point dd9 is of 50°C, the temperature at dd10is 60°C and that the pressure of the steam at points dd8, dd9, dd10 and dd11 is of 70529 Pa. The same equations as the ones of section 2.2.2 are used here.\n\n\nCode\nfrom codes_01_energy_bill.coolprop_functions import mixture\nfrom pyxosmose.state import State\n\nm1_dryer = mass_dd1\n\ncpH2O = 4182 #J/kg\ncpConcMilk = 2610 #J/kg\n\npressure_dryer = 70529 #Pa, it's the saturatioon pressure for 90°C\npressure_dd1 = pressure_dd4 = pressure_dd5 = 20000 #Pa\n\nTemp_dd11 = 318.15\nTemp_dd10 = 333.15\nTemp_dd9 = 323.15\nTemp_dd8 = 363.15\nTemp_dd1 = 277.15\nTemp_dd4 = 333.15\nTemp_dd5 = 333.15\n\nmass_dd8 = (mass_dd4-mass_dd5)/79\nmass_dd9 = mass_dd4-mass_dd5 + mass_dd8\nmass_dd10 = mass_dd9\nmass_dd11 = mass_dd10 + mass_dd1-mass_dd4\n\n\ndef evaporator_fct(m_in,m_out1,m_out2,h_in,h_out1,h_out2,cp_in,deltaT,hfg):\n    Q_evap = m_in*cp_in*deltaT - m_in*h_in + m_out1*h_out1 + m_out2*h_out2\n    m_w = (Q_evap)/(hfg)\n    #print('Qevap:',Q_evap)\n    #print('mw:',m_w)\n    return Q_evap, m_w\n\nState_dd1 = mixture(T = Temp_dd1, P = pressure_dd1, frac_water = water_dd1/100, frac_fat = 1-water_dd1/100)\nh1_dryer = State_dd1[\"enthalpy\"]\ncp1_dryer = State_dd1[\"cpmass\"]\n\nState_dd4 = mixture(T = Temp_dd4, P = pressure_dd4, frac_water = water_dd4/100, frac_fat = 1-water_dd4/100)\nh4_dryer = State_dd4[\"enthalpy\"]\ncp4_dryer = State_dd4[\"cpmass\"]\n\nState_dd5 = mixture(T = Temp_dd5, P = pressure_dd5, frac_water = water_dd5/100, frac_fat = 1-water_dd5/100)\nh5_dryer = State_dd5[\"enthalpy\"]\ncp5_dryer = State_dd5[\"cpmass\"]\n\n#We assume T9 goes to 50C so it can go back to 60 for T10 and pressure is the ambient pressure\n\nPoint_dd9 = State(pair='TP', fluid='water', temperature=Temp_dd9, pressure=pressure_dryer)\nPoint_dd9.StateCalc()\nState_dd9 = Point_dd9.__dict__\nh9_dryer = State_dd9[\"enthalpy\"]\ncp9_dryer = State_dd9[\"cpmass\"]\n\nPoint_dd8 = State(pair='TP', fluid='water', temperature=Temp_dd8, pressure=pressure_dryer)\nPoint_dd8.StateCalc()\nState_dd8 = Point_dd8.__dict__\nhfg8_dryer = State_e24[\"enthalpy\"]\ncp8_dryer = State_dd8[\"cpmass\"]\n\ncp14_dryer = cp8_dryer\n\nQ2_dryer, m_w_2_dryer = evaporator_fct(mass_dd4, mass_dd4-mass_dd5, mass_dd5, h4_dryer, h9_dryer, h5_dryer, cp4_dryer, 40, hfg8_dryer)\n#print(Q2_dryer)\n\nPoint_dd10 = State(pair='TP', fluid='water', temperature=Temp_dd10, pressure=pressure_dryer)\nPoint_dd10.StateCalc()\nState_dd10 = Point_dd10.__dict__\nhfg10_dryer = State_dd10[\"enthalpy\"]\n\nPoint_dd11 = State(pair='TP', fluid='water', temperature=Temp_dd11, pressure=pressure_dryer)\nPoint_dd11.StateCalc()\nState_dd11 = Point_dd11.__dict__\nh11_dryer = State_dd11[\"enthalpy\"]\n\nQ3_dryer, m_w_3_dryer = evaporator_fct(mass_dd1, mass_dd1-mass_dd4 + mass_dd4-mass_dd5, mass_dd4, h1_dryer, h11_dryer, h4_dryer, cp1_dryer, 15, hfg10_dryer)\n#print(Q3_dryer)\n\ndata_param = {'Position': ['1', '4', '5', '8', '9', '10', '11'],\n            'Mass flow (kg/s)': [mass_dd1, mass_dd4, mass_dd5, mass_dd8, mass_dd9, mass_dd10, mass_dd11],\n            'Temperature (K)': [Temp_dd1, Temp_dd4, Temp_dd5, Temp_dd8, Temp_dd9, Temp_dd10, Temp_dd11],\n            'Pressure (Pa)': [pressure_dd1, pressure_dd4, pressure_dd5, pressure_dryer, pressure_dryer, pressure_dryer, pressure_dryer]}\n\ndfp = pd.DataFrame(data_param)\ndfp = dfp.set_index('Position')\ndfp = dfp.round(4)\nHTML(dfp.to_html())\n\n\n\n\n\n\nMass flow (kg/s)\nTemperature (K)\nPressure (Pa)\n\n\nPosition\n\n\n\n\n\n\n\n1\n1.3200\n277.15\n20000\n\n\n4\n0.7343\n333.15\n20000\n\n\n5\n0.6875\n333.15\n20000\n\n\n8\n0.0006\n363.15\n70529\n\n\n9\n0.0474\n323.15\n70529\n\n\n10\n0.0474\n333.15\n70529\n\n\n11\n0.6331\n318.15\n70529\n\n\n\n\n\nCode\ndata_q = {'Dryer': ['Dryer 1', 'Dryer 2'],\n        'Heat demand (W)': [Q3_dryer, Q2_dryer]}\n\ndfq = pd.DataFrame(data_q)\ndfq = dfq.set_index('Dryer')\ndfq = dfq.round(2)\nHTML(dfq.to_html())\n\n\n\n\n\n\nHeat demand (W)\n\n\nDryer\n\n\n\n\n\nDryer 1\n267875.02\n\n\nDryer 2\n67081.68\n\n\n\n\n\n\n\n2.3.3 Heating demand of each HEX\nIn this section the following equation is used:\n\\begin{align}\n    Q = m \\cdot cp \\cdot (T_{1} - T_{2})\n\\end{align}\nThe cp corresponding to the milk mixtures were calculated in the precedent section.\n\n\nCode\ndata_cp = {'Position': ['5', '9', '14'],\n        'cp (J/kg.K)': [ cp5_dryer, cp9_dryer, cp14_dryer]}\n\ndfcp = pd.DataFrame(data_cp)\ndfcp = dfcp.set_index('Position')\ndfcp = dfcp.round(2)\nHTML(dfcp.to_html())\n\n\n\n\n\n\ncp (J/kg.K)\n\n\nPosition\n\n\n\n\n\n5\n2225.45\n\n\n9\n4181.41\n\n\n14\n4205.27\n\n\n\n\n\nCode\nQHEX1_dryer = mass_dd8*cp8_dryer*(Temp_dd8-Temp_dd11)\nQHEX2_dryer = mass_dd9*cp9_dryer*(Temp_dd10-Temp_dd9)\nQHEX3_dryer = mass_dd5*cp5_dryer*(10)\n\ndata_QHEX = {'HEX': ['1', '2', '3'],\n        'Q (W)': [ QHEX1_dryer, QHEX2_dryer, QHEX3_dryer]}\n\ndfqhex = pd.DataFrame(data_QHEX)\ndfqhex = dfqhex.set_index('HEX')\ndfqhex = dfqhex.round(2)\nHTML(dfqhex.to_html())\n\n\n\n\n\n\nQ (W)\n\n\nHEX\n\n\n\n\n\n1\n112.16\n\n\n2\n1982.70\n\n\n3\n15299.94\n\n\n\n\n\n\n\n2.3.4 Water demand to cool down the milk powder\nIt is assumed that the water used to cool down the milk powder is saturated. As such, the following formula can be used:\n\\begin{align}\n    Q = m_{water} \\cdot L_{water}\n\\end{align}\n\n\nCode\nLwater = 2264.705\nmass_water = QHEX3_dryer / Lwater\n\ndata_water = {'HEX': ['3'],\n        'Mass flow (kg/s)': [ mass_water]}\n\ndfw = pd.DataFrame(data_water)\ndfw = dfw.set_index('HEX')\ndfw = dfw.round(2)\nHTML(dfw.to_html())\n\n\n\n\n\n\nMass flow (kg/s)\n\n\nHEX\n\n\n\n\n\n3\n6.76\n\n\n\n\n\n\n\n2.3.5 Steam demand to heat up the air\nThe steam demand can be computed in the same way as the water demand by inverting the sign of the latent heat parameter. The steam is assumed to be saturated.\n\n\nCode\nLwaterEvap = 2264.705\nmass_steam1 = QHEX1_dryer / LwaterEvap\nmass_steam2 = QHEX2_dryer / LwaterEvap\n\ndata_steam = {'HEX': ['1', '2'],\n        'Mass flow (kg/s)': [ mass_steam1, mass_steam2]}\n\ndfs = pd.DataFrame(data_steam)\ndfs = dfs.set_index('HEX')\ndfs = dfs.round(2)\nHTML(dfs.to_html())\n\n\n\n\n\n\nMass flow (kg/s)\n\n\nHEX\n\n\n\n\n\n1\n0.05\n\n\n2\n0.88\n\n\n\n\n\n\n\n2.3.6 Water exiting the system\nThe amount of water exiting the system at dd13 is simply the difference of mass between dd11 and dd8:\n\n\nCode\nwater_exiting = mass_dd11 - mass_dd8\n\ndata_water_exiting = {'Position': ['13'],\n        'Mass flow (kg/s)': [ water_exiting]}\n\ndfwe = pd.DataFrame(data_water_exiting)\ndfwe = dfwe.set_index('Position')\ndfwe = dfwe.round(2)\nHTML(dfwe.to_html())\n\n\n\n\n\n\nMass flow (kg/s)\n\n\nPosition\n\n\n\n\n\n13\n0.63\n\n\n\n\n\n\n\n2.3.7 Summary for the Drum Dryers section\nThis table is a summary of the characteristics of each point of this section:\n\n\nCode\nmass_dd6 = mass_dd5\nmass_dd7 = mass_dd6\nmass_dd12 = mass_dd11\nmass_dd13 = water_exiting\nmass_dd14 = mass_dd8\n\nTemp_dd6 = 323.15\nTemp_dd7 = Temp_dd6\nTemp_dd12 = Temp_dd11\nTemp_dd13 = 318.15\nTemp_dd14 = Temp_dd13\n\ndryer_summary = {'Position': ['1', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14'],\n            'Mass Flow (kg/s)': [mass_dd1, mass_dd4, mass_dd5, mass_dd6, mass_dd7, mass_dd8, mass_dd9, mass_dd10, mass_dd11, mass_dd12, mass_dd13, mass_dd14],\n            'Temperature (K)': [Temp_dd1, Temp_dd4, Temp_dd5, Temp_dd6, Temp_dd7, Temp_dd8, Temp_dd9, Temp_dd10, Temp_dd11, Temp_dd12, Temp_dd13, Temp_dd14]}\n\ndfsd = pd.DataFrame(dryer_summary)\ndfsd = dfsd.set_index('Position')\ndfsd = dfsd.round(4)\nHTML(dfsd.to_html())\n\n\n\n\n\n\nMass Flow (kg/s)\nTemperature (K)\n\n\nPosition\n\n\n\n\n\n\n1\n1.3200\n277.15\n\n\n4\n0.7343\n333.15\n\n\n5\n0.6875\n333.15\n\n\n6\n0.6875\n323.15\n\n\n7\n0.6875\n323.15\n\n\n8\n0.0006\n363.15\n\n\n9\n0.0474\n323.15\n\n\n10\n0.0474\n333.15\n\n\n11\n0.6331\n318.15\n\n\n12\n0.6331\n318.15\n\n\n13\n0.6325\n318.15\n\n\n14\n0.0006\n318.15"
  },
  {
    "objectID": "02.00-process_description.html#cleaning-in-place",
    "href": "02.00-process_description.html#cleaning-in-place",
    "title": "2  Process description and analysis",
    "section": "2.4 Cleaning in Place",
    "text": "2.4 Cleaning in Place\n\n\n\nCleaning in Place\n\n\nAssumptions:\n\nFor safety purposes the glass needs to contact with water which is at least at 65°C. Each glass bottle weights 370 g and has 500 mL of capacity.\n\nFor this part of the process, the following data are used:\n\nMass Flows \\dot{m}_2 = 4\\,kg/s\nSpecific Heats\n\nc_{p,water} = 4.184\\,kJ/kgK (Specific heat of liquid water)\nc_{p,glass} = 0.840\\,kJ/kgK (Specific heat of glass: “Table of Specific Heats” (n.d.))\nh_{fg, steam} = 2257\\,kJ/kg (Latent heat of steam at 100^\\circ C)\n\nTemperatures\n\nT_1 = 25°C = 298\\,K\nT_2 = 60°C = 333\\,K\nT_3 = T_{10} = 80°C = 353\\,K\nT_4 = T_5 = T_6 = T_{12} = 75°C = 348\\,K\nT_7 = 30°C = 303\\,K\nT_8 = 25°C = 298\\,K\nT_{11} = 40°C = 313\\,K\nT_{steam} = 100°C = 373\\,K (Steam pressure is assumed at 1 bar)\n\n\n\n\nCode\ncp_water=4.184\ncp_glass=0.84\nhfg_cipsteam = 2257\n\nm_cip2=4\n\nt_cip1=298\nt_cip2=333\nt_cip3=353\nt_cip4=348\nt_cip5 = t_cip4\nt_cip6 = t_cip4\nt_cip7=303\nt_cip8=298\nt_cip11=313\nt_cip10 = t_cip3\nt_cip12 = t_cip4\nt_cipsteam = 373\n\n\n\n2.4.1 Mixer\nThe first component is an adiabatic mixer (enthalpy stays constant over the mixing). There are three different flows assumed to be water flow (according to pressure and temperature flows). Two in flows and on out flow. We can obtain the mass and energy balance at the mixer as follows: \n\\dot{m}_{CIP,1}cp_{water}T_{CIP,1}+\\dot{m}_{CIP,5}cp_{water}T_{CIP,5}=\\dot{m}_{CIP,2}cp_{water}T_{CIP,2}\n\\tag{2.16} \n\\dot{m}_{CIP,1}+\\dot{m}_{CIP,5}=\\dot{m}_{CIP,2}\n\\tag{2.17}\n\n\nCode\nm_cip1 = m_cip2*(t_cip2-t_cip5)/(t_cip1-t_cip5) \nm_cip5 = m_cip2-m_cip1\n\n\nHence, m_{CIP,1} is equal to 1.2 kg/s and m_{CIP,5} is equal to 2.8 kg/s.\n\n\n2.4.2 Heater\nThe next step is to compute balances of the upper HX (between Steam and point 2 and 3). At this HX, there is mixed water at 60^\\circ C which is heated to 80^\\circ C. The steam used to heat up the water is assumed to be at 1 bar (costs saving reason). Again we have the following equations to compute the heat exchanged and the mass flow of steam (NB: mass flow of water is constant over the HX). \nQ_{CIPHX,steam}=\\dot{m}_{CIP,2}Cp_{water}(T_{CIP,3}-T_{CIP,2})\n\\tag{2.18}\n\nQ_{CIPHX,steam}=\\dot{m}_{steam}h_{fg,steam}\n\\tag{2.19}\n\n\nCode\nq_cipsteam = m_cip2*cp_water*(t_cip3-t_cip2)\nm_cipsteam = q_cipsteam/hfg_cipsteam\n\n# Splitting between CIP-3 and CIP-10 \np = 0.5 # assumed for ease of calculation\nm_cip3 = m_cip2*p\nm_cip10 = m_cip2*(1-p)\n\n\nThere is 334.72 kW heat exchanged thanks to a 0.1483031 kg/s steam flow.\n\n\n2.4.3 Showers\nIt has been assume for ease of calculation that both showers received the same exact mass flow of hot water. Thus, \\dot{m}_{3} = \\dot{m}_{4} = \\dot{m}_{10} = \\dot{m}_{12}= \\dot{m}_{shower}=\\frac{\\dot{m}_2}{2} Furthermore, it is assumed that there is no heat loss through radiation. It is also assumed the mass of the bottle will stay constant the entire process (from part 8 to part 11) and thus: \\dot{m}_8 = \\dot{m}_9 = \\dot{m}_{11} = \\dot{m}_{glass}.\nThe heat balance for the first shower is as followed:  \\dot{m}_{glass}c_{p,glass}(T_9-T_8)=\\dot{m}_{shower}c_{p,water}(T_{3}-T_4) Then for shower 2:  \\dot{m}_{glass}c_{p,glass}(T_{11}-T_9)=\\dot{m}_{shower}c_{p,water}(T_{10}-T_{12})\n\n\nCode\nQ_shower=m_cip3*cp_water*(t_cip3-t_cip4) #same w/ m_cip4\nt_cip9=(t_cip11+t_cip8)/2\nm_cipglass = Q_shower/(cp_glass*(t_cip9-t_cip8))\nm_cip8 = m_cipglass\nm_cip9 = m_cipglass\nm_cip11 = m_cipglass\n\n\nThus, there is 41.84 kW of heat used at each shower and bottle flow rate is 6.6412698 kg/s.\n\n\n2.4.4 Splitter\n\n\nCode\nm_cip4 = m_cip3\nm_cip6 = 2*m_cip4-m_cip5\nm_cip12 = m_cip4\n\n\nNo heat exchanged. Only mass flows such that  \\dot{m}_{4}+\\dot{m}_{12}=\\dot{m}_{2}=\\dot{m}_{5}+\\dot{m}_{6} This gives \\dot{m}_6 is equal to 1.2 kg/s.\n\n\n2.4.5 Cooler\n\n\nCode\nt_cwater_in = 283\nt_cwater_out = 298\nm_cip7 = m_cip6\nq_cipwater = m_cip6*(t_cip6-t_cip7)*cp_water\nm_cipwater = q_cipwater/((t_cwater_out-t_cwater_in)*cp_water)\n\n\nThe final steps of this cleaning process is with the of a HX as a cooler. hot water will be cooled down to 30^\\circ C. As showed above with calculations for the HX_Steam there is thus 225.94 kW transferred thanks to a 3.6 kg/s cooling water flow (which is itself going from 10^\\circ C to 25^\\circ C).\n\n\n2.4.6 Summary for the Cleaning in Place section"
  },
  {
    "objectID": "02.00-process_description.html#cold-storage-hot-water",
    "href": "02.00-process_description.html#cold-storage-hot-water",
    "title": "2  Process description and analysis",
    "section": "2.5 Cold Storage & Hot Water",
    "text": "2.5 Cold Storage & Hot Water\nHere are reported calculation of air mass flow required to remove 500kW of heat from a cold storage and the heat required to heat 1kg/s of water from 15°C to 55°C.\n\n\nCode\nfrom pyxosmose.state import State\n\nwater_in = State(pair='TP',fluid='Water',temperature=288,pressure=100000)\nwater_in.StateCalc()\nwater_out = State(pair='TP',fluid='Water',temperature=328,pressure=100000)\nwater_out.StateCalc()\n\nh_in=water_in.enthalpy \nm_water=1\nh_out=water_out.enthalpy \nQ_hot=m_water*(h_out-h_in)\n#print Q_hot rounded at 2 digits\nprint('The heat required to heat 1kg/s of water from 15°C to 55°C is', round(Q_hot,2), 'W.')\n\n\nThe heat required to heat 1kg/s of water from 15°C to 55°C is 167253.23 W.\n\n\n\n\nCode\nT_in=273\nT_out=268\nQ_fridge=500000\nCp_air=1000\nm_air=Q_fridge/(Cp_air*(T_in-T_out))\nprint('The air mass flow required to remove 500kW of heat from a cold storage is', m_air, 'kg/s.')\n\n\nThe air mass flow required to remove 500kW of heat from a cold storage is 100.0 kg/s."
  },
  {
    "objectID": "02.00-process_description.html#wastewater-and-sludge-production",
    "href": "02.00-process_description.html#wastewater-and-sludge-production",
    "title": "2  Process description and analysis",
    "section": "2.6 WasteWater and Sludge Production",
    "text": "2.6 WasteWater and Sludge Production\n\n\n\nWastewater\n\n\nFor this process we just have to focus on computing liquid and dry matter mass flows for each of the 4 flows (dw_{tot}=dw_{dry}+dw_{liq}). The discharge will only contains liquid water whereas the sludge is a mixture of 13.3wt% fry matter and 86.7wt% water (Shi et al. (2021)). From this paper, the following equations enables to deduce the waste water produced (WP) as well as the sludge produced (SP):\n\nWP = WRM \\times RM\n\\tag{2.20}\n\nSP = SW \\times WP\n\\tag{2.21}\n\nSW = \\frac{\\frac{ES}{RMa}}{WRM}\n\\tag{2.22}\nWhere WRM is the wastewater to raw milk ratio (-) and RM is the Raw Milk processing volume (m^3/s), SW is the sludge to wastewater ratio (kg/m^3), ES is the estimated annual sludge produced (kg), RMa is the annual milk production (m^3), WP is the wastewater produced (m^3/s) and SP is the amount of sludge produced (kg/s).\nFrom the data given we have that RM=8kg/s and Asherruzzaman gives us that WRM=2.71\\pm 0.9 in average. Thus the produced waste water is 0.021 m^3/s given a milk density of 1035kg/m^3.\nThen from 2017 data in Asherruzzaman we have that ES=110000t, RMa=7163000m^3 and thus SW=\\frac{\\frac{110000000}{7163000}}{2.71}=5.59kg/m^3. Thus the produced sludge is SP = 5.59 \\times 0.021 = 0.1174\\text{kg/s}.\nThere is also the assumption that dw3 is only sludge and dw4 only water (dw_{tot2}=dw_{tot3}+dw_{tot4}). In dw3, the quantity of dry matter is again assume to be 13.3wt% and thus the quantity of water is 86.7wt%. The total mass entering the system is WP and because of mass balance, the dry quantity exiting at dw3 must be the same that at dw2 and dw1 (because there is no dry matter in dw4). Finally, we assume that WP density is around that of water (1000kg/m3). Thus, we have the following table to sum up the results:\n\nDischarge water and sludge production streams mass composition\n\n\n\n\n\n\n\n\nStream\n\\dot{m}_{dry}\\,(kg/s)\n\\dot{m}_{liquid}\\,(kg/s)\n\\dot{m}_{total}\n\n\n\n\ndw1\n0.0156\n20.9844\n21\n\n\ndw2\n0.0156\n20.9844\n21\n\n\ndw3\n0.01561\n0.1018\n0.1174\n\n\ndw4\n0\n20.8826\n20.8826"
  },
  {
    "objectID": "02.00-process_description.html#rivella-production",
    "href": "02.00-process_description.html#rivella-production",
    "title": "2  Process description and analysis",
    "section": "2.7 Rivella Production",
    "text": "2.7 Rivella Production\n\n\n\nRivella\n\n\nHaving a better understanding of dairy process, it is now possible to evaluate the energy and mass balance of Rivella production to be able to compare later its costs with the digester. The process is described in the following figure:\nThe process will be divided in 3 main parts:\n\nThe concentration of the whey\nThe production of Rivella Green\nThe production of Rivella Red\n\n\n2.7.1 The concentration of the whey\nAll the whey is assumed to come from the evaporator stage with the following characteristics:\n\n14.46 % of dry matter,\n85.54 % of water,\nT = 4°C,\np = 1 bar,\nmass flow rate of 1.52 kg/s.\n\nAt the end of the concentration process the whey will have the following characteristics:\n\n50 % of dry matter,\n50 % of water,\nT = 100°C,\np = 1 bar,\nmass flow rate to be determined.\n\nWe assume, the following: in the fermentation we have heating from 4 to 25°C, the mixer is isothermal and the evaporator is adiabatic. Also the bacterias are added at T = 25°C and without disturbing the flow rate of the whey (m1 = m3, m4 = 0 m/ s) and the aromas are added at T = 25°C with 2g aromas/100g of whey. Bacteria and aromas have the same heat capacity as water (c_p=4184\\,J/kgK). The pressure stays constant at 1 bar.\n\n\nCode\nfrom codes_01_energy_bill.coolprop_functions import mixture\nfrom pyxosmose.state import State\n\n#Fixed Parameters\nm1=1.52 #kg.s-1\nm2=0 #kg.s-1\nm3=1.52 #kg.s-1\nm4=0.02*m3 #kg.s-1\nm5=m3+m4 #kg.s-1\n#to get m6 we assume that R6 is only water and that the flow is a mixture of fat and water\n#m6=1*mw6+0*mf6 so m6=mw6\n#mw7=0.5m7=0.5*(m5-m6)\n#mw6=mw5-mw7=0.8554*m5-0.5*(m5-m6)\n#m6=[0.8554*m5-0.5*m5]/0.5\nm6=(0.8554*m5-0.5*m5)/0.5 #kg.s-1\nm7=m5-m6 #kg.s-1\n\nT1=277 #K\nT2=298 #K\nT3=T2 #K\nT4=T2 #K\nT5=T2 #K\nT6=373 #K\nT7=T6 #K\n\nTsteam_out = 373 #K\n\np=1 #bar\n\nR1 = mixture(T=T1, P=p, frac_water=0.8554, frac_fat=0.1446) # this is a dictionary!!\ncp1=R1[\"cpmass\"]\nh1=R1[\"enthalpy\"]\n\n#Fermentation \nQferm = m1*cp1*(T2-T1) #J/s\n\n#Evaporator\nTsteam=373 #K\nSteam = State(pair='TP', fluid='water', temperature=Tsteam, pressure=p)\nSteam.StateCalc()\nState_Steam = Steam.__dict__ # Whole dictionary with properties\nhfg=State_Steam[\"enthalpy\"]\n\nh5=h1\ncp5=cp1\n\nR6 = mixture(T=T6, P=p, frac_water=1, frac_fat=0) # this is a dictionary!!\nh6=R6[\"enthalpy\"]\n\nR7 = mixture(T=T7, P=p, frac_water=0.5, frac_fat=0.5) # this is a dictionary!!\nh7=R7[\"enthalpy\"]\ncp7=R7[\"cpmass\"]\n\nQevap = m5*cp5*(T7-T5) - m5*h5 + m6*h6 + m7*h7 #J/s\nmsteam = Qevap/hfg #kg/s\nprint('Qevap =', round(Qevap,2), 'W')\n\n\nQevap = 579418.18 W\n\n\n\n\n2.7.2 The production of Rivella Green\n30% of the concentrated whey is used for the Rivella Green production The composition of the Rivella Green is the following:\n\n30% whey,\n50% water,\n20% sugar.\n\nTea is added at T = 50°C, without disturbing the flow rate of the Rivella Green (m8 = m10, m9 = 0 m/s) The sugar and water are added are added at T = 25°C (will thus cool the fluid and reduce the requirement for a steep change through HX2) and thus the mixer 3 is not isothermal anymore. CO2 is added without change of temperature and pressure (isothermal mixer) and without changing the mass flow (the content of gas in each bottle is not known). The Rivella Green exits at T = 10°C. The pressure stays constant at 1 bar during the entire production.\n\n\nCode\n#Fixed Parameters\nm8=0.3*m7 #kg.s-1\nm10=m8 #kg.s-1\nm9=0 #kg.s-1\n\nTA=298 #K ref temperature\nT8=323 #K\nT9=323 #K\nT10=T8\nT11=298\nT12=T11\nT16=283 #K\nT14=T16\nT15=T16\n\n#HX1: heater\nQHX1=m7*cp7*(T7-T8) #J/s\n\n#Mixer 3\n#We first have to determine the different flows of this non-isothermal mixer\n#we will use the composition of Rivella Green and assume water comes from both R10 (50% of the conc whey) and R11\n#m13=m10+m11+m12\n#m11=0.5*m13-0.5*m10\n#m12=0.2*m13\n\nm13=(0.5*m10)/0.3 #kg.s-1\nm14=m13\nm16=m14\nm11=0.5*m13-0.5*m10\nm12=0.2*m13\n\nR10 = mixture(T=T10, P=p, frac_water=0.5, frac_fat=0.5) # this is a dictionary!!\ncp10=R10[\"cpmass\"]\n\nR11 = mixture(T=T11, P=p, frac_water=1, frac_fat=0) # this is a dictionary!!\ncp11=R11[\"cpmass\"]\nh11=R11[\"enthalpy\"]\n\ncp12=1224 #J/kgK\n\ncp13 = 0.3*cp10 + 0.5*cp11 + 0.2*cp12\n\n#From the heat balance of non-isothermal mixer we can then determine the temperature of the Rivella Green T13\n#m13*cp13*(T13-TA)=m10*cp10*(T10-TA)+m11*cp11*(T11-TA)+m12*cp12*(T12-TA)\n\nT13=((m10*cp10*(T10-TA)+m11*cp11*(T11-TA)+m12*cp12*(T12-TA))/(m13*cp13))+TA\n\n#HX2: cooler1\nQHX2=m13*cp13*(T13-T14) #J/s\n\nprint(' QHX1 =', round(QHX1,2), 'W', '\\n', 'QHXgreen =', round(QHX2,2), 'W')\n\n\n QHX1 = 40112.41 W \n QHXgreen = 12711.81 W\n\n\n\n\n2.7.3 The production of Rivella Red\n70% of the concentrated whey is used for the Rivella Red production. The composition of the Rivella Red is the following:\n\n30% whey,\n35% water,\n35% sugar.\n\nThe sugar and water are added are added at T = 25°C (will thus cool the fluid and reduce the requirement for a steep change through HX2) and thus the mixer 3 is not isothermal anymore. CO2 is added without change of temperature and pressure (isothermal mixer) and without changing the mass flow (because the content of gas in each bottle is not known). The Rivella Red exits as Rivella Green at T = 10°C. The pressure stays constant at 1 bar during the entire production.\n\n\nCode\n#Fixed Parameters\nm17=0.7*m7 #kg.s-1\n\nT17=T8 #K\nT18=T11\nT19=T11\nT23=T16 #K\nT22=T23\nT21=T23\n\n#Mixer 4\n#We first have to determine the different flows of this non-isothermal mixer\n#we will use the composition of Rivella Green and assume water comes from both R17 (50% of the conc whey) and R18\n#m20=m17+m18+m19\n#m18=0.35*m20-0.5*m17\n#m19=0.35*m20\nm20=(0.5*m17)/0.3 #kg.s-1\nm21=m20\nm23=m21\nm18=0.35*m20-0.5*m17\nm19=0.35*m20\n\nR17 = mixture(T=T17, P=p, frac_water=0.5, frac_fat=0.5) # this is a dictionary!!\ncp17=R17[\"cpmass\"]\nh17=R17[\"enthalpy\"]\n\nR18 = mixture(T=T18, P=p, frac_water=1, frac_fat=0) # this is a dictionary!!\ncp18=R18[\"cpmass\"]\nh18=R18[\"enthalpy\"]\n\ncp19=1224 #J/kgK\n\ncp20 = 0.3*cp17 + 0.35*cp18 + 0.35*cp19\n\n#From the heat balance of non-isothermal mixer we can then determine the temperature of the Rivella Green T13\n#m20*cp20*(T20-TA)=m17*cp17*(T17-TA)+m18*cp18*(T18-TA)+m19*cp19*(T19-TA)\n\nT20=((m17*cp17*(T17-TA)+m18*cp18*(T18-TA)+m19*cp19*(T19-TA))/(m20*cp20))+TA\n#HX2: cooler1\nQHX3=-m20*cp20*(T21-T20) #J/s\n\nprint('QHXred =', round(QHX3,2), 'W')\n\n\nQHXred = 28907.2 W\n\n\n\n\n2.7.4 Summary for the Rivella production section\n\n\nCode\n#Put everything in a dataframe\nfrom IPython.display import HTML\nimport pandas as pd\nimport numpy as np\n\n#Compute remaining enthalpies and heat capacities\n\ncp2=4184 #J/kgK\n\nh3=h1\ncp3=cp1\n\ncp4=4184 #J/kgK\n\nR6 = State(pair='TP', fluid='water', temperature=T6, pressure=p)\nR6.StateCalc()\nState_R6 = R6.__dict__ # Whole dictionary with properties\nh6=State_R6[\"enthalpy\"]\ncp6=State_R6[\"cpmass\"]\n\nR8 = mixture(T=T8, P=p, frac_water=0.5, frac_fat=0.5) \nh8=R8[\"enthalpy\"]\ncp8=R8[\"cpmass\"]\n\nh10=h8\ncp10=cp8\n\nh12=0 #CHECKKKKKKKKKKK HOW TO GET ENTHALPY SUGAR \n#m13*h13=m10*h10+m11*h11+m12*h12\nh13=((m10*h10+m11*h11+m12*h12)/m13)\n\n#m13(h13-h14)=m13*cp13*(T13-T14)\nh14=h13-m13*cp13*(T13-T14)\ncp14=cp13 #assume no change of cp with cooling for Rivella Green\n\nh16=h14\ncp16=cp13\n\nh19=h16 #CHECKKKKKKKKKKK HOW TO GET ENTHALPY SUGAR\n\n#m20*h20=m17*h17+m18*h18+m19*h19\nh20=((m17*h17+m18*h18+m19*h19)/m20)\n\n#m20(h20-h21)=m20*cp20*(T20-T21)\nh21=h20-m20*cp20*(T20-T21)\ncp21=cp20 #assume no change of cp with cooling for Rivella Red\n\nh23=h21\ncp23=cp20\n\n#Create a dataframe with all the parameters\n\nRivella = pd.DataFrame(columns=['Point', 'Temperature (K)', 'Pressure (bar)', 'Mass flow rate (kg/s)', 'Heat capacity (J/kgK)', 'Enthalpy (J/kg)'])\nRivella['Point']=['1', '2', '3', '4', '5', '6', '7', '8', '9', '10','11','12','13','14','15','16','17','18','19','20','21','22','23']\nRivella['Temperature (K)']=[T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23]\nRivella['Pressure (bar)']=[p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p]\nRivella['Mass flow rate (kg/s)']=[m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,m13,m14,'',m16,m17,m18,m19,m20,m21,'',m23]\nRivella['Heat capacity (J/kgK)']=[cp1,cp2,cp3,cp4,cp5,cp6,cp7,cp8,'',cp10,cp11,cp12,cp13,cp14,'',cp16,cp17,cp18,cp19,cp20,cp21,'',cp23]\nRivella['Enthalpy (J/kg)']=[h1,'',h3,'',h5,h6,h7,h8,'',h10,h11,'h12',h13,h14,'',h16,h17,h18,h19,h20,h21,'',h23]\nRivella = Rivella.set_index('Point')\nRivella = Rivella.round(2)\nHTML(Rivella.to_html())\n\n\n\n\n\n\nTemperature (K)\nPressure (bar)\nMass flow rate (kg/s)\nHeat capacity (J/kgK)\nEnthalpy (J/kg)\n\n\nPoint\n\n\n\n\n\n\n\n\n\n1\n277.00\n1\n1.52\n1896.854714\n2023742.226974\n\n\n2\n298.00\n1\n0\n4184\n\n\n\n3\n298.00\n1\n1.52\n1896.854714\n2023742.226974\n\n\n4\n298.00\n1\n0.0304\n4184\n\n\n\n5\n298.00\n1\n1.5504\n1896.854714\n2023742.226974\n\n\n6\n373.00\n1\n1.102024\n1889.734714\n2688396.124217\n\n\n7\n373.00\n1\n0.448376\n1789.232083\n1190483.719342\n\n\n8\n323.00\n1\n0.134513\n2002.408006\n923714.318925\n\n\n9\n323.00\n1\n0\n\n\n\n\n10\n323.00\n1\n0.134513\n2002.408006\n923714.318925\n\n\n11\n298.00\n1\n0.044838\n1864.353548\n2547701.452782\n\n\n12\n298.00\n1\n0.044838\n1224\nh12\n\n\n13\n314.90\n1\n0.224188\n1777.699176\n1063768.881911\n\n\n14\n283.00\n1\n0.224188\n1777.699176\n1051057.070948\n\n\n15\n283.00\n1\n\n\n\n\n\n16\n283.00\n1\n0.224188\n1777.699176\n1051057.070948\n\n\n17\n323.00\n1\n0.313863\n2002.408006\n923714.318925\n\n\n18\n298.00\n1\n0.026155\n1864.353548\n2547701.452782\n\n\n19\n298.00\n1\n0.183087\n1224\n1051057.070948\n\n\n20\n315.86\n1\n0.523105\n1681.646144\n1049483.638826\n\n\n21\n283.00\n1\n0.523105\n1681.646144\n1020576.433841\n\n\n22\n283.00\n1\n\n\n\n\n\n23\n283.00\n1\n0.523105\n1681.646144\n1020576.433841\n\n\n\n\n\nCode\n#print a data frame with the heating value of the 3 hex\nHX = pd.DataFrame(columns=['HX', 'Heat exchanged (W)'])\nHX['HX']=['Evap', 'HX1', 'HX green', 'HX red']\nHX['Heat exchanged (W)']=[Qevap, QHX1,QHX2,QHX3]\nHX = HX.set_index('HX')\nHX = HX.round(2)\nHTML(HX.to_html())\n\n\n\n\n\n\nHeat exchanged (W)\n\n\nHX\n\n\n\n\n\nEvap\n579418.18\n\n\nHX1\n40112.41\n\n\nHX green\n12711.81\n\n\nHX red\n28907.20"
  },
  {
    "objectID": "02.00-process_description.html#digester",
    "href": "02.00-process_description.html#digester",
    "title": "2  Process description and analysis",
    "section": "2.8 Digester",
    "text": "2.8 Digester\n\n\n\nDigester\n\n\nThe digester module aims to use sludge, consider as trash in milk production, to produce biogas and then make profits of it. In this project, all the whey and only whey is used for rivella production and all the sludge and only sludge is used for biogas production. This module is composed of a digestor to produce biogas, a rotary filter to eliminate some water, and a steam dryer to obtain as output dryed digestate. In order to compute the mass flow and energy balance of the digester module, the computation are split in three parts: the digestor, the rotary filter and the steam dryer.\n\n2.8.1 Digestor\nTo compute the biogas production, the following equation is used:\n\n\\text{Biogas}(t) = \\sum_{i=1}^{n} \\text{Flow}(i) \\cdot \\text{BMP}(i) \\cdot \\text{TS}(i) \\cdot \\text{VS}(i) \\cdot (1 - e^{-k_i t})\n\\tag{2.23}\nFrom litterature Holliger, Fruteau de Laclos, and Hack (2017), in table 2, data for waste sludge are the following:\n\n\\text{TS}_\\text{sludge} = 0.037\n\\text{VS}_\\text{sludge} = 0.742\n\\text{BMP}_\\text{sludge} = 0.407 m^3_{CH4}/kg_{VS}\n\nConsidering 90 % conversion achieved for the given residence time and only sludge is used, the Equation 2.23 can be rewrite as:\n\n\\text{Biogas}(t) = \\text{Flow}_\\text{sludge} \\cdot \\text{BMP}_\\text{sludge} \\cdot \\text{TS}_\\text{sludge} \\cdot \\text{VS}_\\text{sludge} \\cdot 0.90\n\\tag{2.24}\nKnown data:\n\nd_\\text{1,dry} = d_\\text{w3,dry} = 0.01561 kg/s\nd_\\text{1,liquid} = d_\\text{w3,liquid} = 0.1018 kg/S\nCH4_\\text{in biogas} = 0.55 kg_CH4/kg_biogas (55% CH4 in biogas)\nU_\\text{digester} = 2.5 W/m2/°C\nT_\\text{digester} = 55°C\nT_\\text{in} = 20°C\nRatio H/D = 0.6\nMinimum biogas expansion volume: 15%\n\nAssumptions:\n\np = 100000 Pa = 1 bar\n\\rho_\\text{biogas} = 1.15 kg/m3\ncp_\\text{flow} = 4180 J/kg/°C\n\\rho_\\text{CH4} = 0.657 kg/m3\n20 days of residence time\nNo water in biogas d3\n\n\n2.8.1.1 Mass Flow\nWith those informations, the mass flow balance can be computed:\n\n\nCode\nimport numpy as np\nimport pandas as pd\nfrom codes_01_energy_bill.coolprop_functions import mixture\nfrom pyxosmose.state import State\n\np=100000 #Pa\nTS_sludge = 0.037\nVS_sludge = 0.742\nBMP_sludge = 0.407 # m3_CH4/kg_VS\nd1_dry = 0.01561\nd1_liquid = 0.1018\nd1 = d1_dry + d1_liquid\nconversion_factor = 0.90\nCH4_density = 0.657 # kg/m3\nCH4_in_biogas = 0.55 # kg_CH4/kg_biogas (55% CH4 in biogas)\nbiogas_density = 1.15 # kg/m3\nbiogas_expansion = 0.15\nU_digester = 2.5 # W/m2/°C\nT_digester = 55+273 # K\nT_in = 20+273 # K\ncp_flow = 4180 # J/kg/°C\n\nd3 = d1 * BMP_sludge * TS_sludge * VS_sludge * conversion_factor * CH4_density / CH4_in_biogas # kg/s\nd2 = d1 - d3\n\nd2_liquid = d1_liquid # Assumption : no water in biogas d3\nd2_dry = d2 - d2_liquid\n\n# print d1, d2, d3 in a dataframe\ndata = {'Point': ['1', '2', '3'],\n        'Dry Mass flow (kg/s)': [d1_dry, d2_dry, d3],\n        'Liquid Mass flow (kg/s)': [d1_liquid, d2_liquid, 0],\n        'Total Mass flow (kg/s)': [d1, d2, d3]}\ndf = pd.DataFrame(data)\ndf = df.set_index('Point')\ndf = df.round(4)\nHTML(df.to_html())\n\n\n\n\n\n\nDry Mass flow (kg/s)\nLiquid Mass flow (kg/s)\nTotal Mass flow (kg/s)\n\n\nPoint\n\n\n\n\n\n\n\n1\n0.0156\n0.1018\n0.1174\n\n\n2\n0.0142\n0.1018\n0.1160\n\n\n3\n0.0014\n0.0000\n0.0014\n\n\n\n\n\n\n\n2.8.1.2 Digestor Geometry\n\nV_\\text{biogas} = \\frac{d_3 \\cdot \\text{time}}{\\rho_\\text{biogas}}\n\\tag{2.25}\n\nV_\\text{digester} = V_\\text{biogas} \\cdot (1 + \\text{biogas expansion})\n\\tag{2.26}\n\nD = \\left( \\frac{4 \\cdot V_\\text{digester}}{0.6 \\cdot \\pi} \\right)^{1/3}\n\\tag{2.27}\n\nH = 0.6 \\cdot D\n\\tag{2.28}\n\nA = \\pi \\cdot D \\cdot H + 2 \\cdot \\pi \\left( \\frac{D}{2} \\right)^2\n\\tag{2.29}\n\n\nCode\n# Compute the Volume\ntime = 20 * 24 * 3600 # 20 days in seconds\nV_biogas= d3 * time / biogas_density # m3\n\n# Compute the surface area\nV_digester = V_biogas * (1 + biogas_expansion) # m3\n\nD = (4 * V_digester / (0.6 * np.pi))**(1/3) \nH = 0.6 * D\nA = np.pi * D * H + 2 * np.pi * (D/2)**2 # cylindrical digester area\n\n# print in a dataframe the volume, the height, the diameter and the area of the digester\ndata = {'Point': ['Digester'],\n        'Volume (m3)': [V_digester],\n        'Diameter (m)': [D],\n        'Height (m)': [H],\n        'Area (m2)': [A]}\ndf = pd.DataFrame(data)\ndf = df.set_index('Point')\ndf = df.round(2)\nHTML(df.to_html())\n\n\n\n\n\n\nVolume (m3)\nDiameter (m)\nHeight (m)\nArea (m2)\n\n\nPoint\n\n\n\n\n\n\n\n\nDigester\n2437.22\n17.29\n10.38\n1033.5\n\n\n\n\n\nKnowing the surface area of the digester and the Heat transfer coefficient for well-insulated digester U_\\text{digester}, the heat loss can be computed:\n\nQ_\\text{digester} = U_\\text{digester} \\cdot A \\cdot (T_\\text{digester} - T_\\text{in})\n\\tag{2.30}\n\nQ_\\text{flow} = cp_\\text{flow} \\cdot d_1 \\cdot (T_\\text{digester} - T_\\text{in})\n\\tag{2.31}\n\nQ_\\text{tot} = Q_\\text{digester} + Q_\\text{flow}\n\\tag{2.32}\n\n\nCode\n# Compute the heat loss\nQ_digester = U_digester * A * (T_digester - T_in) # W\nQ_flow = cp_flow * d1 * (T_digester - T_in) # W\nQ_tot = Q_digester + Q_flow\n\n# print in a dataframe the 3 losses\ndata = {'Point': ['Digestor', 'Flow', 'Total'],\n        'Heat Loss (W)': [Q_digester, Q_flow, Q_tot]}\ndf = pd.DataFrame(data)\ndf = df.set_index('Point')\ndf = df.round(2)\nHTML(df.to_html())\n\n\n\n\n\n\nHeat Loss (W)\n\n\nPoint\n\n\n\n\n\nDigestor\n90431.39\n\n\nFlow\n17177.08\n\n\nTotal\n107608.48\n\n\n\n\n\n\n\n\n2.8.2 Rotary filter\nThe rotary filter does not consume any heat. It is considered as a mechanical device only. The mass flow is computed as follow:\n\nonly water is removed: d_{5,\\text{dry}} = d_{2,\\text{dry}}\nd5 is composed of 50% wt. H2O (w.b.): d_{5,\\text{liquid}} = d_{5,\\text{dry}}\nd_5 = d_{5,\\text{dry}} + d_{5,\\text{liquid}}\nd4 is fully liquid: d_4 = d_{2,\\text{liquid}} - d_{5,\\text{liquid}}\n\n\n\nCode\n#Rotary Filter\nd5_dry = d2_dry\nd5_liquid = d5_dry\nd5 = d5_dry + d5_liquid\nd4 = d2_liquid - d5_liquid\n\n# print in a data frame the mass flow of dry and liquid for point 4 and 5 and the total mass flow for point 4 and 5\ndata = {'Point': ['4', '5'],\n        'Dry Mass flow (kg/s)': [0, d5_dry],\n        'Liquid Mass flow (kg/s)': [d4, d5_liquid],\n        'Total Mass flow (kg/s)': [d4, d5]}\ndf = pd.DataFrame(data)\ndf = df.set_index('Point')\ndf = df.round(4)\nHTML(df.to_html())\n\n\n\n\n\n\nDry Mass flow (kg/s)\nLiquid Mass flow (kg/s)\nTotal Mass flow (kg/s)\n\n\nPoint\n\n\n\n\n\n\n\n4\n0.0000\n0.0876\n0.0876\n\n\n5\n0.0142\n0.0142\n0.0284\n\n\n\n\n\n\n\n2.8.3 Steam dryer\nThe steam dryer target is to reduced the water composition of the digestate from 50% to 5%. It is assumed that h_\\text{steam} = 2250000 J/kg at T = 100°C.\nThe energy required to evaporate the water is computed as follow: \nQ_\\text{sd} = d_5 \\cdot (0.5 - 0.05) \\cdot h_\\text{steam}\n\\tag{2.33}\nAssumptions:\n\nT_7 = 150°C\nT_8 = 130°C\n\nKnowing this energy, the mass flow of the steam is computed as follow:\n\n90% of the water in d5 is removed: d_6 = d_5 - 0.9 \\cdot d_{5,\\text{liquid}}\nd_7 = d_8 = \\frac{Q_{sd}}{cp7 * (T_7 - T_8)}\n\n\n\nCode\n# Steam dryer\nh_steam = 2250000 # J/kg source wikipedia at T = 100°C\nQ_sd = d5 * (0.5-0.05) * h_steam # W from 50% to 5% water\nprint('Q_sd = ', Q_sd, 'W')\n\n\nQ_sd =  28754.13727822047 W\n\n\nCode\nd6 = d5 - 0.9 * d5_liquid # 90% of the water in d5 is removed\n\nT7 = 150 + 273 # °C  --&gt; is an assumption\nT8 = 130 + 273 # °C  --&gt; is an assumption\n\npoint7 = State(pair='TP', fluid='water', temperature=T7, pressure=p)\npoint7.StateCalc()\npoint7 = point7.__dict__ # Whole dictionary with properties\nh7=point7[\"enthalpy\"]\ncp7=point7[\"cpmass\"]\nd7 = Q_sd / (cp7 * (T7 - T8)) # kg/s\nd8 = d7 + d5*0.9\n\n# print in a dataframe the mass flow of dry and liquid for point 6, 7 and 8 and the total mass flow for point 6, 7 and 8\ndata = {'Point': ['6', '7', '8'],\n        'Dry Mass flow (kg/s)': [d6*0.05, 0, 0],\n        'Liquid Mass flow (kg/s)': [d6*0.95, d7, d8],\n        'Total Mass flow (kg/s)': [d6, d7, d8]}\ndf = pd.DataFrame(data)\ndf = df.set_index('Point')\ndf = df.round(4)\nHTML(df.to_html())\n\n\n\n\n\n\nDry Mass flow (kg/s)\nLiquid Mass flow (kg/s)\nTotal Mass flow (kg/s)\n\n\nPoint\n\n\n\n\n\n\n\n6\n0.0008\n0.0148\n0.0156\n\n\n7\n0.0000\n0.7244\n0.7244\n\n\n8\n0.0000\n0.7499\n0.7499\n\n\n\n\n\n\n\n2.8.4 Summary for the digester section\n\n\nCode\n#Create a dataframe with all the parameters\n\nT1= T_in\nT2= T_digester\nT3= T2\nT4= T2\nT5= 373\nT6= T5\n\ndata = {'Point': ['1', '2', '3', '4', '5', '6', '7', '8'],\n        'Temperature (K)': [T1, T2, T3, T4, T5, T6, T7, T8],\n        'Pressure (bar)': [p, p, p, p, p, p, p, p],\n        'Mass flow rate (kg/s)': [d1, d2, d3, d4, d5, d6, d7, d8]}\ndf = pd.DataFrame(data)\ndf = df.set_index('Point')\ndf = df.round(4)\nHTML(df.to_html())\n\n\n\n\n\n\nTemperature (K)\nPressure (bar)\nMass flow rate (kg/s)\n\n\nPoint\n\n\n\n\n\n\n\n1\n293\n100000\n0.1174\n\n\n2\n328\n100000\n0.1160\n\n\n3\n328\n100000\n0.0014\n\n\n4\n328\n100000\n0.0876\n\n\n5\n373\n100000\n0.0284\n\n\n6\n373\n100000\n0.0156\n\n\n7\n423\n100000\n0.7244\n\n\n8\n403\n100000\n0.7499\n\n\n\n\n\nCode\n#print dataframe with Q_tot (named as Q_digestor in the table) and Q_sd\ndata = {'Point': ['Digestor', 'Steam Dryer'],\n        'Q (W)': [Q_tot, Q_sd]}\ndf = pd.DataFrame(data)\ndf = df.set_index('Point')\ndf = df.round(2)\nHTML(df.to_html())\n\n\n\n\n\n\nQ (W)\n\n\nPoint\n\n\n\n\n\nDigestor\n107608.48\n\n\nSteam Dryer\n28754.14\n\n\n\n\n\n\n\n\n\nHolliger, Christof, Hélène Fruteau de Laclos, and Gabrielle Hack. 2017. “Methane Production of Full-Scale Anaerobic Digestion Plants Calculated from Substrate’s Biomethane Potentials Compares Well with the One Measured On-Site.” Frontiers in Energy Research 5 (June): 12. https://doi.org/10.3389/fenrg.2017.00012.\n\n\nNaghavi, Enayat-Allah, Jalal Dehghannya, and Babak Ghanbarzadeh. 2018. “3D Computational Simulation for the Prediction of Coupled Momentum, Heat and Mass Transfer During Deep-Fat Frying of Potato Strips Coated with Different Concentrations of Alginate.” Journal of Food Engineering 235: 64–78. https://doi.org/https://doi.org/10.1016/j.jfoodeng.2018.04.026.\n\n\nShi, W., M. G. Healy, S. M. Ashekuzzaman, K. Daly, J. J. Leahy, and O. Fenton. 2021. “Dairy Processing Sludge and Co-Products: A Review of Present and Future Re-Use Pathways in Agriculture.” Journal of Cleaner Production 314 (September): 128035. https://doi.org/10.1016/j.jclepro.2021.128035.\n\n\n“Table of Specific Heats.” n.d. Accessed November 14, 2023. http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/sphtt.html#c1."
  },
  {
    "objectID": "03.00-energy_bill.html#exergy-analysis",
    "href": "03.00-energy_bill.html#exergy-analysis",
    "title": "3  Exergy analysis and Energy bill",
    "section": "3.1 Exergy analysis",
    "text": "3.1 Exergy analysis\nTo evaluate the losses and inefficiencies in the dairy production, an exergy analysis is performed. An exergy loss is the difference between the exergy entering a unit and the exergy leaving the unit. This exergy analysis includes calculating heat losses for each component experiencing heat transfer, covering both pasteurization and evaporation processes. The ambient temperature is set at T_a = 25°C + 273K = 293K.\n\n3.1.1 Pasteurization\n\n3.1.1.1 Refrigeration\n\nL_{milk\\_ref} = \\dot{m}_{f\\_milk}c_{p_{f\\_milk}}\\left((T_{f\\_milk} - T_{mixure\\_out}) - T_a \\ln\\left(\\frac{T_{f\\_milk}}{T_{mixure\\_out}}\\right)\\right)\n \nL_{gly\\_ref} = \\dot{m}_{gly\\_ref}c_{p_{glywater}}\\left((T_{f\\_milk} - T_{mixure\\_out}) - T_a \\ln\\left(\\frac{T_{f\\_milk}}{T_{mixure\\_out}}\\right)\\right)\n \nL_{ref} = L_{milk\\_ref} + L_{gly\\_ref}\n\n\n\n3.1.1.2 Past 1\n\nL_{past1\\_1} = \\dot{m}_{f\\_milk}c_{p_{f\\_milk}}\\left((T_{mixure\\_out} - T_{past\\_cent}) - T_a \\ln\\left(\\frac{T_{mixure\\_out}}{T_{past\\_cent}}\\right)\\right)\n \nL_{past1\\_2} = \\dot{m}_{milk}c_{p_{raw\\_milk}}\\left((T_{past\\_c} - T_{past\\_d}) - T_a \\ln\\left(\\frac{T_{past\\_c}}{T_{past\\_d}}\\right)\\right)\n \nL_{past1} = L_{past1\\_1} + L_{past1\\_2}\n\n\n\n3.1.1.3 Past 2\n\nL_{past2\\_1} = \\dot{m}_{milk}c_{p_{raw\\_milk}}\\left((T_{milk\\_0} - T_{past\\_a}) - T_a \\ln\\left(\\frac{T_{milk\\_0}}{T_{past\\_a}}\\right)\\right)\n \nL_{past2\\_2} = \\dot{m}_{milk}c_{p_{raw\\_milk}}\\left((T_{past\\_b} - T_{past\\_c}) - T_a \\ln\\left(\\frac{T_{past\\_b}}{T_{past\\_c}}\\right)\\right)\n \nL_{past2} = L_{past2\\_1} + L_{past2\\_2}\n\n\n\n3.1.1.4 Past 3\n\nL_{past3\\_1} = \\dot{m}_{milk}c_{p_{raw\\_milk}}\\left((T_{past\\_a} - T_{past\\_b}) - T_a \\ln\\left(\\frac{T_{past\\_a}}{T_{past\\_b}}\\right)\\right)\n\n\nL_{past3\\_2} = \\dot{m}_{steam\\_past3}c_{p_{steam}} \\Delta h_3 - T_a \\Delta s_3\n \nL_{past3} = L_{past3\\_1} + L_{past3\\_2}\n\n\n\n3.1.1.5 Past 4\n\nL_{past4\\_1} = \\dot{m}_{milk}c_{p_{raw\\_milk}}\\left((T_{past\\_d} - T_{milk}) - T_a \\ln\\left(\\frac{T_{past\\_d}}{T_{milk}}\\right)\\right)\n \nL_{gly\\_past4} = \\dot{m}_{gly\\_past4}c_{p_{glywater}}\\left((T_{past\\_d} - T_{milk}) - T_a \\ln\\left(\\frac{T_{past\\_d}}{T_{milk}}\\right) \\right)\n \nL_{past4} = L_{past4\\_1} + L_{gly\\_past4}\n\n\n\n3.1.1.6 Past 5\n\nL_{past5\\_1} = \\dot{m}_{int}c_{p_{cream}}\\left((T_{cream} - T_{crpast\\_a}) - T_a \\ln\\left(\\frac{T_{cream}}{T_{crpast\\_a}}\\right)\\right)\n \nL_{past5\\_2} = \\dot{m}_{cream}c_{p_{cream}}\\left((T_{crpast\\_b} - T_{crpast\\_c}) - T_a \\ln\\left(\\frac{T_{crpast\\_b}}{T_{crpast\\_c}}\\right)\\right)\n \nL_{past5} = L_{past5\\_1} + L_{past5\\_2}\n\n\n\n3.1.1.7 Past 6\n\nL_{past6\\_1} = \\dot{m}_{cream}c_{p_{cream\\_mixed}}\\left((T_{crpast\\_x} - T_{crpast\\_b}) - T_a \\ln\\left(\\frac{T_{crpast\\_x}}{T_{crpast\\_b}}\\right)\\right)\n \nL_{past6\\_2} = \\dot{m}_{steam\\_past6}c_{p_{steam}} \\Delta h_6 - T_a \\Delta s_6\n \nL_{past6} = L_{past6\\_1} + L_{past6\\_2}\n\n\n\n3.1.1.8 Past 7\n\nL_{past7\\_1} = \\dot{m}_{cream}c_{p_{cream}}\\left((T_{crpast\\_c} - T_{cream}) - T_a \\ln\\left(\\frac{T_{crpast\\_c}}{T_{cream}}\\right)\\right)\n \nL_{gy\\_past7} = \\dot{m}_{gly\\_past7}c_{p_{glywater}}\\left((T_{crpast\\_c} - T_{cream}) - T_a \\ln\\left(\\frac{T_{crpast\\_c}}{T_{cream}}\\right)\\right)\n \nL_{past7} = L_{past7\\_1} + L_{gy\\_past7}\n\n\n\n3.1.1.9 Mixer\n\nL_{mixer\\_1} = \\dot{m}_{cream}c_{p_{cream}}\\left((T_{crpast\\_a} - T_{crpast\\_x}) - T_a \\ln\\left(\\frac{T_{crpast\\_a}}{T_{crpast\\_x}}\\right)\\right)\n \nL_{mixer\\_2} = \\dot{m}_{thick}c_{p_{alboline}}\\left((T_{thick} - T_{crpast\\_x}) - T_a \\ln\\left(\\frac{T_{thick}}{T_{crpast\\_x}}\\right)\\right)\n \nL_{mixer} = L_{mixer\\_1} + L_{mixer\\_2}\n\n\n\n3.1.1.10 Total\n\nL_{tot\\_past} = L_{ref} + L_{past1} + L_{past2} + L_{past3} + L_{past4} + L_{past5} + L_{past6} + L_{past7} + L_{mixer}\n\n\n\n3.1.1.11 Summary of Pasteurization Exergy Results\n\n\nCode\n#path &lt;- file.path('./venv/Scripts/python.exe')\n#library(reticulate)\n#use_python(path)\n\n\n\n\nCode\n#import math\nimport pandas as pd\nimport numpy as np\nfrom IPython.display import display, HTML\n\ndf = pd.read_csv('pasteurization_process.csv',sep = ';')\n\nfor i in range(0,len(df.index)):\n    globals()[df.iloc[i][1]] = df.iloc[i][2]\n\nDelta_T_Gly=5\nTa=298\n\n#Refrigeration\nL_milk_ref=m_fmilk*Cp_fmilk*((T_fmilk-T_mixure_out)-T_a*np.log(T_fmilk/T_mixure_out))\n\nL_gy_ref=m_gly_ref*Cp_glywater*((Delta_T_Gly)-T_a*np.log(T_fmilk/T_mixure_out))#glywater temperature\n\nL_ref=L_milk_ref+L_gy_ref\n\n\n#Past 1\n\nL_past1_1=m_fmilk*Cp_fmilk*((T_mixure_out-T_past_cent)-T_a*np.log(T_mixure_out/T_past_cent))\nL_past1_2=m_milk*Cp_raw_milk*((T_past_c-T_past_d)-T_a*np.log(T_past_c/T_past_d) )\n\nL_past1=L_past1_1+L_past1_2\n\n#Past 2\n\nL_past2_1=m_milk*Cp_raw_milk*((T_past_a-T_milk_0)-T_a*np.log(T_past_a/T_milk_0))  \nL_past2_2=m_milk*Cp_raw_milk*((T_past_c-T_past_b)-T_a*np.log(T_past_c/T_past_b)) \n\nL_past2_1=m_milk*Cp_raw_milk*((T_milk_0-T_past_a)-T_a*np.log(T_milk_0/T_past_a))  \nL_past2_2=m_milk*Cp_raw_milk*((T_past_b-T_past_c)-T_a*np.log(T_past_b/T_past_c)) \n\nL_past2=L_past2_1+L_past2_2\n\n\n#Past 3\n\nL_past3_1=m_milk*Cp_raw_milk*((T_past_b-T_past_a)-T_a*np.log(T_past_b/T_past_a))\n\nL_past3_2=m_steam_past3*(delta_h_steam-T_a*delta_s_steam)\n\nL_past3=L_past3_1#L_past3_2-\n\n\n#Past 4\n\nL_past4_1=m_milk*Cp_raw_milk*((T_milk-T_past_d)-T_a*np.log(T_milk/T_past_d))\n\nL_gy_past4=m_gly_past4*Cp_glywater*((T_milk-T_past_d)-T_a*np.log(T_milk/T_past_d))#glywater temperature\n\nL_past4=L_past4_1+L_gy_past4\n\n\n#Past 5\nL_past5_1=m_int*Cp_cream*((T_crpast_a-T_cream)-T_a*np.log(T_crpast_a/T_cream))\nL_past5_2=m_cream*Cp_cream*((T_crpast_c-T_crpast_b)-T_a*np.log(T_crpast_c/T_crpast_b))\n\nL_past5=L_past5_1+L_past5_2\n\n\n#Past 6\nL_past6_1=m_cream*Cp_cream_mixed*((T_crpast_x-T_crpast_b)-T_a*np.log(T_crpast_x/T_crpast_b))\nL_past6_2=m_steam_past6*(delta_h_steam-Ta*delta_s_steam)\n\nL_past6=L_past6_1+L_past6_2\n\n\n#Past 7\n\nL_past7_1=m_cream*Cp_cream*((T_crpast_c-T_cream)-T_a*np.log(T_crpast_c/T_cream))\n\nL_gy_past7=m_gly_past7*Cp_glywater*((T_crpast_c-T_cream)-T_a*np.log(T_crpast_c/T_cream))#glywater temperature\n\nL_past7=L_past7_1+L_gy_past7\n\n\n#Mixer\n\nL_mixer_1=m_cream*Cp_cream*((T_crpast_a-T_crpast_x)-T_a*np.log(T_crpast_a/T_crpast_x))\nL_mixer_2=m_thick*Cp_alboline*((T_crpast_x-T_thick)-T_a*np.log(T_crpast_x/T_thick))\n\nL_mixer=L_mixer_1+L_mixer_2\n\n\n#Total exergy pasteurisation section\n\nL_tot_past= L_ref+L_past1+L_past2+L_past3+L_past4+L_past5+L_past6+L_past7+L_mixer\n\n#Calculations for Sankey Diagram\n\nL_steam_in=m_steam_past3*(2880000-480*7343)\nL_steam_out=m_steam_past3*(461000-383*1.418)\nL_fresh_milk=m_fmilk*Cp_fmilk*((T_mixure_out-T_past_cent)-T_a*np.log(T_mixure_out/T_past_cent))\n\n\n# Dataframe for Exergy Loss Pasteurization\n\nExergy_losses  = 'kW'\n\nVariables_Names = ['L_Refrigeration','L_Past1','L_Past2','L_Past3','L_Past4','L_Past5','L_Past6','L_Past7','L_mixer','L_tot_past']\nVariables_Values = np.divide([L_ref,L_past1,L_past2,L_past3,L_past4,L_past5,L_past6,L_past7,L_mixer,L_tot_past],1000)\nVariables_Units =  Exergy_losses\ndf = pd.DataFrame(data = {'Exergy loss': Variables_Names, 'Value':Variables_Values, 'Unit': Variables_Units})\ndisplay(df)\n\n\n       Exergy loss       Value Unit\n0  L_Refrigeration   38.795385   kW\n1          L_Past1   44.142703   kW\n2          L_Past2    3.672032   kW\n3          L_Past3   37.456417   kW\n4          L_Past4   32.953363   kW\n5          L_Past5    1.645935   kW\n6          L_Past6  115.552815   kW\n7          L_Past7   77.747824   kW\n8          L_mixer    2.129568   kW\n9       L_tot_past  354.096042   kW\n\n\nCode\nHTML(df.to_html(index=False))\n\n\n\n\n\nExergy loss\nValue\nUnit\n\n\n\n\nL_Refrigeration\n38.795385\nkW\n\n\nL_Past1\n44.142703\nkW\n\n\nL_Past2\n3.672032\nkW\n\n\nL_Past3\n37.456417\nkW\n\n\nL_Past4\n32.953363\nkW\n\n\nL_Past5\n1.645935\nkW\n\n\nL_Past6\n115.552815\nkW\n\n\nL_Past7\n77.747824\nkW\n\n\nL_mixer\n2.129568\nkW\n\n\nL_tot_past\n354.096042\nkW\n\n\n\n\n\n\n\n\n3.1.2 Evaporation\n\n3.1.2.1 Heat Exchanger\n\nL_{heat1} = m_{11}(h_{11} - T_a s_{11}) - m_{12}(h_{12} - T_a s_{12}) + m_1(h_1 - T_a s_1) - m_2(h_2 - T_a s_2)\n \nL_{heat2} = -m_2(h_2 - T_a s_2) + m_3(h_3 - T_a s_3) - m_{16}(h_{16} - T_a s_{16})\n \nL_{heat3} = -m_3(h_3 - T_a s_3) + m_4(h_4 - T_a s_4) - m_{20}(h_{20} - T_a s_{20})\n \nL_{heat4} = -m_4(h_4 - T_a s_4) + m_5(h_5 - T_a s_5) + m_{15}(h_{15} - T_a s_{15})\n\n\n\n3.1.2.2 Heat Evaporator\n\nL_{eva1} = -m_6(h_6 - T_a s_6) + m_7(h_7 - T_a s_7) + m_{14}(h_{14} - T_a s_{14}) - m_{21}(h_{21} - T_a s_{21})\n \nL_{eva2} = -m_8(h_8 - T_a s_8) - m_{17}(h_{17} - T_a s_{17}) + m_{15}(h_{15} - T_a s_{15}) + m_9(h_9 - T_a s_9)\n \nL_{eva3} = -m_{10}(h_{10} - T_a s_{10}) + m_{18}(h_{18} - T_a s_{18}) + m_{16}(h_{16} - T_a s_{16}) + m_{11}(h_{11} - T_a s_{11})\n\n\n\n3.1.2.3 Splitter\nThere are no exergy losses in the splitters since they are isenthalpic\n\n\n3.1.2.4 Total\n\n\\dot{L}_{evaporation}=\\Sigma\\dot{L}_{HX}+\\Sigma\\dot{L}_{evaporator}+\\Sigma\\dot{L}_{splitter}\n\n\n\n3.1.2.5 Results Exergy Analysis Evaporation\n\n\nCode\n#Exergy Evaporation\n\n#import math\nimport pandas as pd\nimport numpy as np\nfrom IPython.display import display, HTML\n\ndfrecap = pd.read_csv('dfrecap.csv', sep = ',')\n\nfor i in range(0,len(dfrecap.index)):\n    globals()['m'+str(i+1)] = dfrecap['Mass flow (kg/s)'].iloc[i]\n    globals()['h'+str(i+1)] = dfrecap['Enthalpy (J/mol)'].iloc[i]\n    globals()['s'+str(i+1)] = dfrecap['Entropy (J/K)'].iloc[i]\n\n\n#Exergy for heat exchangers\n\nTa=298\n\nL_heat1 = m11*(h11-Ta*s11)-m12*(h12-Ta*s12)+m1*(h1-Ta*s1)-m2*(h2-Ta*s2)\n\nL_heat2= -m2*(h2-Ta*s2)+m3*(h3-Ta*s3)-m16*(h16-Ta*s16)\n\n\nL_heat3=-m3*(h3-Ta*s3)+m4*(h4-Ta*s4)-m20*(h20-Ta*s20)\n\n\nL_heat4=-m4*(h4-Ta*s4)+m5*(h5-Ta*s5)+m15*(h15-Ta*s15)\n\n\n#Exergy for evaporators\n\nL_eva1=-m6*(h6-Ta*s6)+m7*(h7-Ta*s7)+m14*(h14-Ta*s14)-m21*(h21-Ta*s21)\n\n\nL_eva2=-m8*(h8-Ta*s8)-m17*(h17-Ta*s17)+m15*(h15-Ta*s15)+m9*(h9-Ta*s9)\n\n\nL_eva3=-m10*(h10-Ta*s10)+m18*(h18-Ta*s18)+m16*(h16-Ta*s16)+m11*(h11-Ta*s11)\n\n\n#Total exergy evaporation section\n\nL_tot_eva= L_heat1+L_heat2+L_heat3+L_heat4+L_eva1+L_eva2+L_eva3\n\n\n# Dataframe for Exergy Loss Evaporation\n\nExergy_losses  = 'kW'\n\nVariables_Names = ['L_heat1','L_heat2','L_heat3','L_heat4','L_eva1','L_eva2','L_eva3','L_tot_eva']\nVariables_Values = np.divide([L_heat1,L_heat2,L_heat3,L_heat4,L_eva1,L_eva2,L_eva3,L_tot_eva],1000)\nVariables_Units =  Exergy_losses\ndf_2 = pd.DataFrame(data = {'Exergy loss': Variables_Names, 'Value':Variables_Values, 'Unit': Variables_Units})\n\ndisplay(df_2)\n\n\n  Exergy loss       Value Unit\n0     L_heat1   22.237824   kW\n1     L_heat2    8.707640   kW\n2     L_heat3   29.767800   kW\n3     L_heat4    7.340070   kW\n4      L_eva1   62.347310   kW\n5      L_eva2   95.726653   kW\n6      L_eva3    0.804831   kW\n7   L_tot_eva  226.932129   kW\n\n\nCode\ndisplay(HTML(df_2.to_html(index=False)))\n\n\n&lt;IPython.core.display.HTML object&gt;\n\n\n\n\n\n3.1.3 Suggested modifications\nFrom the previous calculations, one can see that the total exergy lost to the environment from the pasteurization and evaporation processes is more than 1700 kW. This value indicates that the inefficiencies in both processes are very large. For the pasteurization process, the exergy loss is especially significant in Past 3, as steam enters and leaves the system. In the evaporation part, the exergy loss is particularly high in Evaporator 1 and Evaporator 2.\nTo decrease the overall exergy losses in the system, different strategies can be implemented. Since the exergy efficiencies are so large the best option is to improve the general energy efficiency by upgrading to more energy-efficient equipment and using insulation.\n\n\nCode\nsource(\"./sankey_ipese.R\") # introduce the sankey function from the source file\ndf = read.csv('atom_balance.csv',sep = '\\t') # replace the atom_balance.csv with your exergy analysis results\nsankey_ipese(df = df, unit = 'kmol/h', title = 'Example of an interactive Sankey diagram') # replace the unit and title here"
  },
  {
    "objectID": "03.00-energy_bill.html#energy-bill",
    "href": "03.00-energy_bill.html#energy-bill",
    "title": "3  Exergy analysis and Energy bill",
    "section": "3.2 Energy bill",
    "text": "3.2 Energy bill\n\n\nCode\n#print dataframe with the price of electricity and natural gas in France and Germany\nimport pandas as pd\nimport numpy as np\nfrom IPython.display import display, HTML\n\nelec_fr = 0.12 # €/kWh\nelec_ger = 0.21 # €/kWh\ngas_fr = 0.08 # €/kWh\ngas_gr = 0.08 # €/kWh\n\nprice = pd.DataFrame({'France (€/kWh)':[elec_fr, gas_fr], 'Germany (€/kWh)':[elec_ger, gas_gr]}, index = ['Electricity', 'Natural gas'])\nprice = price.round(3)\nHTML(price.to_html())\n\n\n\n\n\n\nFrance (€/kWh)\nGermany (€/kWh)\n\n\n\n\nElectricity\n0.12\n0.21\n\n\nNatural gas\n0.08\n0.08\n\n\n\n\n\nNow, let list all the assumptions used to computed the energy bill:\n\nThe factory is running 95% of the time (8322 hours per year)\nCOP of the refrigeration system is 3.5\nAll water is used in closed loop. The cost is not taken into account in OPEX but will be in CAPEX.\n\n\n\n\n\n\n\n\n\n\nHeating\nCooling\n\n\n\n\nPasteurization\nQpast_3, Qpast_6\nQpast_ref, Qpast_4, Qpast_7\n\n\nEvaporation\nQevap_st1\nQevap_5\n\n\nDryer\nQdry_hx1, Qdry_hx2\nQdry_cool\n\n\nCleaning\nQclean_heat\nQclean_cool\n\n\nStorage & hot water\nQhot_water\nQ_storage\n\n\nRivella\nQrivella_heat\n\n\n\nDigester\nQdigester_dq, Qdigester_steam\n\n\n\n\nThe electricity consumption for cooling is computed as follow:\n\nElec(kW)= Q(kW) / COP\n\\tag{3.1}\nThe OPEX cost is computed as follow:\n\nOPEX(M€/y)= Q(kW) \\cdot t_{\\text{op}} (h/y) \\cdot price(€/kWh) \\cdot 10^{-6} (M€/€)\n\\tag{3.2}\n\n\nCode\ntop = 24*0.95*365 #h/year\n\n#Pasterization\nQpast_ref = 60416 #W    \nQpast_4 = 194370 #W  \nQpast_7 = 127000 #W    \nQpast_3 = 285760 #W   \nQpast_6 = 35610 #W    \n\nQpast_cool = Qpast_ref + Qpast_4 + Qpast_7\nQpast_heat = Qpast_3 + Qpast_6 \n\n#Evap\nQevap_5 = 55703.14  #W\nQevap_st1 = 98038.87 #W\nQevap_cool = Qevap_5\nQevap_heat = Qevap_st1\n\n#Dryer\nQdry_cool = 15299.94 #W\nQdry_hx1 =  112.16 #W\nQdry_hx2 =  1967.71#W\nQdry_cool = Qdry_cool\nQdry_heat = Qdry_hx1 + Qdry_hx2 \n\n#Cleaning\nQclean_cool = 225940 #W\nQclean_heat = 334710 #W\n\n#Storage & hot water\nQ_storage = 500000  #W\nQhot_water = 167253.2 #W\n\n#Rivella\nQrivella_heat =  579418.2 #W\n\n#Digester\nQdigester_dq1 = 28754.1 #W\nQdigester_steam = 107608.5 #W\nQdigester_heat = Qdigester_dq1 + Qdigester_steam\n\n#Cool cost\nCOP = 3.5 # assumption\nQcool_tot = (Qpast_cool + Qevap_cool + Qdry_cool + Qclean_cool + Q_storage)/COP\nOPEXcool_fr = Qcool_tot*0.001 * elec_fr * top\nOPEXcool_ger = Qcool_tot*0.001 * elec_ger *top\n\n#Heat cost\nQheat_tot = Qpast_heat + Qevap_heat + Qdry_heat + Qclean_heat + Qhot_water + Qrivella_heat + Qdigester_heat\nOPEXheat_fr = Qheat_tot*0.001 * gas_fr * top\nOPEXheat_ger = Qheat_tot*0.001 * gas_gr * top\n\n#print in a dataframe the OPEX line: cooling, heating and total and column: France, Germany\nOPEX = pd.DataFrame({'France (M€/y)':[OPEXcool_fr/1e6, OPEXheat_fr/1e6, OPEXcool_fr/1e6 + OPEXheat_fr/1e6], 'Germany (M€/y)':[OPEXcool_ger/1e6, OPEXheat_ger/1e6, OPEXcool_ger/1e6 + OPEXheat_ger/1e6]}, index = ['Cooling', 'Heating', 'Total'])\nOPEX = OPEX.round(3)\nHTML(OPEX.to_html())\n\n\n\n\n\n\nFrance (M€/y)\nGermany (M€/y)\n\n\n\n\nCooling\n0.336\n0.589\n\n\nHeating\n1.091\n1.091\n\n\nTotal\n1.428\n1.680\n\n\n\n\n\nCode\n\n\n#OPEX_past_5_fr = Qpast_6*0.001 * gas_fr * top + (Qpast_7/COP)*0.001 * elec_fr * top\n#OPEX_past_5_ger = Qpast_6*0.001 * gas_gr * top + (Qpast_7/COP)*0.001 * elec_ger * top\n#print('OPEX_past_5_fr', OPEX_past_5_fr)\n#print('OPEX_past_5_ger', OPEX_past_5_ger)\n\n#OPEX_past1_5_fr = (Qpast_6+Qpast_3)*0.001 * gas_fr * top + ((Qpast_7+Qpast_4)/COP)*0.001 * elec_fr * top\n#OPEX_past1_5_ger = (Qpast_6+Qpast_3)*0.001 * gas_gr * top + ((Qpast_7+Qpast_4)/COP)*0.001 * elec_ger * top\n#print('OPEX_past1_5_fr', OPEX_past1_5_fr)\n#print('OPEX_past1_5_ger', OPEX_past1_5_ger)\n\n#OPEX_CIP_fr = (Qclean_heat)*0.001 * gas_fr * top + ((Qclean_cool)/COP)*0.001 * elec_fr * top\n#OPEX_CIP_ger = (Qclean_heat)*0.001 * gas_gr * top + ((Qclean_cool)/COP)*0.001 * elec_ger * top\n#print('OPEX_CIP_fr', OPEX_CIP_fr)\n#print('OPEX_CIP_ger', OPEX_CIP_ger)"
  },
  {
    "objectID": "04.00-HeatRecovery.html#optimization-of-deltat-minimum",
    "href": "04.00-HeatRecovery.html#optimization-of-deltat-minimum",
    "title": "4  Pinch analysis",
    "section": "4.1 Optimization of \\DeltaT minimum",
    "text": "4.1 Optimization of \\DeltaT minimum\n\n\nThe goal of this part is to determine an optimized dTmin such that costs are minimized. In all scenarios we will do the following: - Determine the area of the HX in term of the dTmin - Determine the cost of the HX in term of the the Area - Determine the cost of the HX in term of the dTmin\nThe costs will be computed for both France and Germany and will be composed of CAPEX and OPEX.\nThe idea is too be able to determine if this optimized dTmin enables costs reduction compared to the assumed ∆Tmin of 5K in the Mass/Energy Balances and Energy Bill.\nFour different scenarios will be considered: - Past 5 only - Past 1 + Past 5 combined - An addditional heat recovery for pasteurization - Heat Recovery in Cleaning In Place (CIP) process\nThe three first scenari focus on the pasterization process whereas the later is about the CIP process.\n\n4.1.1 Past 5 only\nHere past 5 costs is optimized with respect to dTmin. In our code 1 stands for cold stream and 2 for hot stream. When we have a T#number it is related to the entrance of te stream and _prime relate to the exiting The _Number stands for the past number Example: T2_prime_2 stands for the T_hout of the past2 HX, T1_5 stands for the T_cin of the past5 HX\n\n\nCode\n\n### Determine the area of the HX in term of the dTmin\nimport matplotlib\nmatplotlib.use('Agg')\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom IPython.display import display, HTML\nfrom codes_01_energy_bill.coolprop_functions import mixture\n\n#####\ndef Dtmin(dT, T1, T1v, T2v, T2, m1, m2, cp1, cp2, position, pastnb):\n\n    if position == 'right':\n        T1_prime = T2 - dT\n        T2_prime = T2v.min()\n    elif position == 'left':\n        T1_prime = T1v.max()\n        T2_prime = T1 + dT #T1v.max()\n    \n    #Find the minimum Area of the HX\n    Q = m2*cp2*(T2-T2_prime)\n    #print('Q = ', round(Q, 3), 'W')\n    alpha= 1000 #W/m^2°C, assumption based on alpha_H20 since 65wt% of the stream is water \n    U = alpha/2\n    dtA = abs(T2-T1_prime)  # to be sure we have a positive value in the ln() of the LMTD\n    dtB = abs(T1-T2_prime)\n    LMTD = (dtA-dtB)/np.log(dtA/dtB)\n    Area = Q/(U*LMTD)\n\n    #Find the CAPEX\n\n    CEPCI2019=603.1 \n    CEPCI1998=389.5 #https://personalpages.manchester.ac.uk/staff/tom.rodgers/Interactive_graphs/CEPCI.html?reactors/CEPCI/index.html\n    K1=3.6788 #sl 12 T4.1 assumption spiral plate HX\n    K2=0.4412\n    FBM=4.74 #assumption fluid sl 10 T4.1\n    i=0.05 #sl 8 T4.2\n    e=0.92 #€/$ exchange rate 2023 Nov \n    n=20\n\n    Cp = CEPCI2019/CEPCI1998 * 10**(K1+K2*np.log(Area))\n\n    CBM = Cp*FBM*e\n\n    ANNUALIZATIONFACTOR = (i*(1+i)**n)/((1+i)**n-1)\n\n    CAPEX = ANNUALIZATIONFACTOR*CBM\n\n    #Find the OPEX\n    top = 24*0.95*365 #h/year\n    gas_fr = 0.08 # €/kWh\n    gas_ger = 0.08 # €/kWh \n    elec_fr = 0.12 # €/kWh\n    elec_ger = 0.21 # €/kWh\n    COP = 3.5 #same assumption in Energy Bill\n\n    if pastnb == 5:\n        Qpast6 = m2*cp2*(T2-T1_prime)\n        OP6_fr = gas_fr * Qpast6/1000 * top\n        OP6_ger = gas_ger * Qpast6/1000 * top\n\n        Qpast7 = m2*cp2*(T2_prime-277)  #T7 = 4°C = 277K\n        Wpast7 = Qpast7/COP\n\n        OP7_fr = elec_fr * Wpast7/1000 * top  \n        OP7_ger = elec_ger * Wpast7/1000 * top \n\n        OPEX_fr = OP6_fr + OP7_fr\n        OPEX_ger = OP6_ger + OP7_ger\n\n    elif pastnb == 1:\n        Qpast2 = m2*cp2*5 # dt = 5 in past 2\n        Tpast2out = T1_prime + Qpast2/(m2*cp2)\n\n        Qpast3 = m2*cp2*(Tpast2out-348)\n\n        OP3_fr = gas_fr * Qpast3/1000 * top\n        OP3_ger = gas_ger * Qpast3/1000 * top\n\n        Qpast4 = m2*cp2*(T2_prime-277)  #T7 = 4°C = 277K\n        Wpast4 = Qpast4/COP\n\n        OP4_fr = elec_fr * Wpast4/1000 * top  \n        OP4_ger = elec_ger * Wpast4/1000 * top \n\n        OPEX_fr = OP3_fr + OP4_fr\n        OPEX_ger = OP3_ger + OP4_ger\n    \n    elif pastnb == 'cip':\n        Qsteam = m1*cp1*(353-T1_prime)\n        OP_steam_cip_fr = gas_fr * Qsteam/1000 * top\n        OP_steam_cip_ger = gas_ger * Qsteam/1000 * top\n\n        Qcool = m2*cp2*(T2_prime-277)\n        Wcool = Qcool/COP\n        OP_cool_cip_fr = elec_fr * Wcool/1000 * top\n        OP_cool_cip_ger = elec_ger * Wcool/1000 * top\n\n        OPEX_fr = OP_steam_cip_fr + OP_cool_cip_fr\n        OPEX_ger = OP_steam_cip_ger + OP_cool_cip_ger\n\n    #Find the TOTEX\n    TOTEX_fr = CAPEX + OPEX_fr\n    TOTEX_ger = CAPEX + OPEX_ger\n\n    return CAPEX, OPEX_fr, OPEX_ger, TOTEX_fr, TOTEX_ger, Area, T1_prime, T2_prime\n\n\n\n\nCode\n# Scenario 1: dTmin for the past5\n\nT1_5 = 333\nT2_5 = 348\n\np1_5 = 100000\n\nm1_5 = 0.48\nm2_5 = 0.55\n\nState_Cold_1_5 = mixture(T=T1_5, P=p1_5, frac_water=0.65, frac_fat=0.35)\nState_Cold_2_5 = mixture(T=T2_5, P=p1_5, frac_water=0.65, frac_fat=0.35)\n\nh1_5 = State_Cold_1_5[\"enthalpy\"] * m1_5  #from mixture with dry = 35% and wet = 65%\nh2_5 = State_Cold_2_5[\"enthalpy\"] * m2_5\n\ncp1_5 = State_Cold_1_5[\"cpmass\"]\ncp2_5 = State_Cold_2_5[\"cpmass\"]\n\nslope1_5 = 1/(m1_5*cp1_5)\nslope2_5 = 1/(m2_5*cp2_5)\n\n#Plot the two lines with T on the y-axis and h on the x-axis\n#h is the enthalpy of the stream between h1 and h2\nN = 100\nh_5 = np.linspace(h1_5, h2_5, N)\n\nC1_5 = T1_5 - slope1_5*h1_5\nT1v_5 = slope1_5*h_5 + C1_5\n\nC2_5 = T2_5 - slope2_5*h2_5\nT2v_5 = slope2_5*h_5 + C2_5\n\n\n# Create trace for Cold Stream\ntrace_cold = go.Scatter(x=h_5, y=T1v_5, mode='lines', name='Cold Stream')\n# Create trace for Hot Stream\ntrace_hot = go.Scatter(x=h_5, y=T2v_5, mode='lines', name='Hot Stream')\n# Create layout\nlayout = go.Layout(\n    title='Temperature vs Enthalpy',\n    xaxis=dict(title='Enthalpy (J)'),\n    yaxis=dict(title='Temperature (K)'),\n    legend=dict(x=0, y=1, traceorder='normal'),\n    showlegend=True\n)\n# Create figure\nfig = go.Figure(data=[trace_cold, trace_hot], layout=layout)\n# Plot the vertical line at dTmin\ndt_5 = T2v_5 - T1v_5\ndTmin_5 = dt_5.min()\nmin_index_5 = dt_5.argmin()\nfig.add_shape(\n    type='line',\n    x0=h_5[min_index_5],\n    x1=h_5[min_index_5],\n    y0=min(T1v_5[min_index_5], T2v_5[min_index_5]),\n    y1=max(T1v_5[min_index_5], T2v_5[min_index_5]),\n    line=dict(color='red', dash='dash')\n)\n\n\n\n                        \n                                            \n\n\nCode\nprint('dTmin =', round(dTmin_5, 3), 'K at h =', round(h_5[min_index_5], 3), 'kJ/kg')\n\n\ndTmin = 1.61 K at h = -21384.368 kJ/kg\n\n\nCode\n#Redo the CAPEX/OPEX/TOTEX for different dT and plot the results\n\nCAPEXv_5 = []\nOPEX_frv_5 = []\nOPEX_gerv_5 = []\nTOTEX_frv_5 = []\nTOTEX_gerv_5 = []\nAreav_5 = []\n\ndt_5 = np.linspace(0.1, 30, 300)\n\nfor t in dt_5:\n    CAPEX_5, OPEX_fr_5, OPEX_ger_5, TOTEX_fr_5, TOTEX_ger_5, Area_5 = Dtmin(t, T1_5, T1v_5, T2v_5, T2_5, m1_5, m2_5, cp1_5, cp2_5, 'right', 5)[0:6]\n    CAPEXv_5.append(CAPEX_5)\n    OPEX_frv_5.append(OPEX_fr_5)\n    OPEX_gerv_5.append(OPEX_ger_5)\n    TOTEX_frv_5.append(TOTEX_fr_5)\n    TOTEX_gerv_5.append(TOTEX_ger_5)\n    Areav_5.append(Area_5)\n\n#plot the results with respect to the dt values\n\n# Create traces for each cost component\ntrace_capex = go.Scatter(x=dt_5, y=CAPEXv_5, mode='lines', name='CAPEX', line=dict(color='black'))\ntrace_opex_france = go.Scatter(x=dt_5, y=OPEX_frv_5, mode='lines', name='OPEX (France)', line=dict(color='blue'))\ntrace_opex_germany = go.Scatter(x=dt_5, y=OPEX_gerv_5, mode='lines', name='OPEX (Germany)', line=dict(color='red'))\ntrace_totex_france = go.Scatter(x=dt_5, y=TOTEX_frv_5, mode='lines', name='TOTEX (France)', line=dict(color='blue', dash='dash'))\ntrace_totex_germany = go.Scatter(x=dt_5, y=TOTEX_gerv_5, mode='lines', name='TOTEX (Germany)', line=dict(color='red', dash='dash'))\n\n# Create layout\nlayout = go.Layout(\n    title='Costs vs dTmin',\n    xaxis=dict(title='dTmin (K)'),\n    yaxis=dict(title='Costs (€)'),\n    legend=dict(x=0, y=-0.2, traceorder='normal', orientation='h'),\n    showlegend=True\n)\n\n# Create figure\nfig = go.Figure(data=[trace_capex, trace_opex_france, trace_opex_germany, trace_totex_france, trace_totex_germany], layout=layout)\n\n# Mark the minima points for both France and Germany\nmin_index_fr_5 = np.argmin(TOTEX_frv_5)\nfig = fig.add_trace(go.Scatter(x=[dt_5[min_index_fr_5]], y=[TOTEX_frv_5[min_index_fr_5]], mode='markers', marker=dict(color='blue'), name='Min TOTEX (France)'))\n\nmin_index_ger_5 = np.argmin(TOTEX_gerv_5)\nfig = fig.add_trace(go.Scatter(x=[dt_5[min_index_ger_5]], y=[TOTEX_gerv_5[min_index_ger_5]], mode='markers', marker=dict(color='red'), name='Min TOTEX (Germany)'))\n\n# Show the figure\nfig.show()\n\n\n\n                        \n                                            \n\n\nCode\n#print the optimum values for dt, area, CAPEX, OPEX, TOTEX for both France and Germany (NB: even if we have the same CAPEX fct for both countries, the optimum CAPEX will be different in both countries because of the electricity/gas rate)\n\ndtmin_fr_opt_5 = dt_5[min_index_fr_5]\ndtmin_ger_opt_5 = dt_5[min_index_ger_5]\narea_fr_opt_5 = Areav_5[min_index_fr_5]\narea_ger_opt_5 = Areav_5[min_index_ger_5]\nCAPEX_fr_opt_5 = CAPEXv_5[min_index_fr_5]\nCAPEX_ger_opt_5 = CAPEXv_5[min_index_ger_5]\nOPEX_fr_opt_5 = OPEX_frv_5[min_index_fr_5]\nOPEX_ger_opt_5 = OPEX_gerv_5[min_index_ger_5]\nTOTEX_fr_opt_5 = TOTEX_frv_5[min_index_fr_5]\nTOTEX_ger_opt_5 = TOTEX_gerv_5[min_index_ger_5]\n\nPast5_opt_fr_sc1 = pd.DataFrame({'dTmin_fr[K]': dtmin_fr_opt_5, 'Area_fr[m^2]': area_fr_opt_5, 'CAPEX_fr[€/yr]': CAPEX_fr_opt_5, 'OPEX_fr[€/yr]': OPEX_fr_opt_5, 'TOTEX_fr[€/yr]': TOTEX_fr_opt_5}, index=[0])\nPast5_opt_fr_sc1 = Past5_opt_fr_sc1.round(2)\nHTML(Past5_opt_fr_sc1.to_html(index=False))\n\n\n\n\n\ndTmin_fr[K]\nArea_fr[m^2]\nCAPEX_fr[€/yr]\nOPEX_fr[€/yr]\nTOTEX_fr[€/yr]\n\n\n\n\n9.4\n7.6\n20311.81\n44419.74\n64731.55\n\n\n\n\n\nCode\nPast5_opt_ger_sc1 = pd.DataFrame({'dTmin_ger[K]': dtmin_ger_opt_5, 'Area_ger[m^2]': area_ger_opt_5, 'CAPEX_ger[€/yr]': CAPEX_ger_opt_5, 'OPEX_ger[€/yr]': OPEX_ger_opt_5, 'TOTEX_ger[€/yr]': TOTEX_ger_opt_5}, index=[0])\nPast5_opt_ger_sc1 = Past5_opt_ger_sc1.round(2)\nHTML(Past5_opt_ger_sc1.to_html(index=False))\n\n\n\n\n\ndTmin_ger[K]\nArea_ger[m^2]\nCAPEX_ger[€/yr]\nOPEX_ger[€/yr]\nTOTEX_ger[€/yr]\n\n\n\n\n9.4\n7.6\n20311.81\n68745.31\n89057.12\n\n\n\n\n\n\n\n\n4.1.2 Past 1 + Past 5\nThis time we know only T_{c,in} and T_{c,out} but nothing about the hot streams. We can’t reuse the exact same method as for past5 where we knew T_{h,in} and T_{c,in} We will then first need to determine T_{h,in} from the Past2 ∆T (assumed here at 5K for simplicity). We end up with a T_{past,c} = 70°C which will be T_{h,in} of past1. Another important assumption in this scenario is to assume for past1 that T_{c,out}=T_{past,out} \\ne 60°C. Indeed, we will instead determine this temperature from the ∆Tmin optimization of past1. From this new T_{c,out}, and because both past1 and past5 are linked by this flow we will recompute the ∆Tmin optimization of past5. Overall we will be able to compare (for both France and Germany scenario) which scenario is the most cost efficient.\n\n\nCode\nfrom codes_01_energy_bill.coolprop_functions import mixture\n# Scenario 2: dTmin for the past1+past5\n\n####################################\n############## PAST1 ##############\n####################################\n\nT1_1 = 277\nT2_1 = 343\n\np1_1 = 100000\n\nm1_1 = 8\nm2_1 = 7.52\n\nState_Cold_1_1 = mixture(T=T1_1, P=p1_1, frac_water=0.883, frac_fat=0.117)\nState_Cold_2_1 = mixture(T=T2_1, P=p1_1, frac_water=0.883, frac_fat=0.117)\n\nh1_1 = State_Cold_1_1[\"enthalpy\"] * m1_1  #from mixture with dry = 11.7% and wet = 88.3%\nh2_1 = State_Cold_2_1[\"enthalpy\"] * m2_1\n\ncp1_1 = State_Cold_1_1[\"cpmass\"]\ncp2_1 = State_Cold_2_1[\"cpmass\"]\n\nslope1_1 = 1/(m1_1*cp1_1)\nslope2_1 = 1/(m2_1*cp2_1)\n\n#Plot the two lines with T on the y-axis and h on the x-axis\n#h is the enthalpy of the stream between h1 and h2\nN = 100\nh_1 = np.linspace(h1_1, h2_1, N)\n\nC1_1 = T1_1 - slope1_1*h1_1\nT1v_1 = slope1_1*h_1 + C1_1\n\nC2_1 = T2_1 - slope2_1*h2_1\nT2v_1 = slope2_1*h_1 + C2_1\n\n\n# Create trace for Cold Stream\ntrace_cold = go.Scatter(x=h_1, y=T1v_1, mode='lines', name='Cold Stream')\n# Create trace for Hot Stream\ntrace_hot = go.Scatter(x=h_1, y=T2v_1, mode='lines', name='Hot Stream')\n# Create layout\nlayout = go.Layout(\n    title='Temperature vs Enthalpy',\n    xaxis=dict(title='Enthalpy (J)'),\n    yaxis=dict(title='Temperature (K)'),\n    legend=dict(x=0, y=1, traceorder='normal'),\n    showlegend=True\n)\n# Create figure\nfig = go.Figure(data=[trace_cold, trace_hot], layout=layout)\n# Plot the vertical line at dTmin\ndt_1 = abs(T2v_1 - T1v_1)\ndTmin_1 = dt_1.min()\nmin_index_1 = dt_1.argmin()\nfig = fig.add_shape(\n    type='line',\n    x0=h_1[min_index_1],\n    x1=h_1[min_index_1],\n    y0=min(T1v_1[min_index_1], T2v_1[min_index_1]),\n    y1=max(T1v_1[min_index_1], T2v_1[min_index_1]),\n    line=dict(color='red', dash='dash')\n)\n# Show the figure\nfig.show()\n\n\n\n                        \n                                            \n\n\nCode\nprint('dTmin = ', round(dTmin_1,3), 'K at h = ', round(h_1[min_index_1],3), 'kJ/kg')\n\n\ndTmin =  0.001 K at h =  -90044.132 kJ/kg\n\n\nCode\n#This time the the dTmin is on the left of the curves and thus dTmin = T_hout-T_cin (instead of T_hin-Tcout as in past6)\n\n#Redo the CAPEX/OPEX/TOTEX for different dT and plot the results\n\nCAPEXv_1 = []\nOPEX_frv_1 = []\nOPEX_gerv_1 = []\nTOTEX_frv_1 = []\nTOTEX_gerv_1 = []\nAreav_1 = []\n\ndt_1 = np.linspace(10, 65, 500)\n\nfor t in dt_1:\n    CAPEX_1, OPEX_fr_1, OPEX_ger_1, TOTEX_fr_1, TOTEX_ger_1, Area_1 = Dtmin(t, T1_1, T1v_1, T2v_1, T2_1, m1_1, m2_1, cp1_1, cp2_1, 'left', 1)[0:6]\n    CAPEXv_1.append(CAPEX_1)\n    OPEX_frv_1.append(OPEX_fr_1)\n    OPEX_gerv_1.append(OPEX_ger_1)\n    TOTEX_frv_1.append(TOTEX_fr_1)\n    TOTEX_gerv_1.append(TOTEX_ger_1)\n    Areav_1.append(Area_1)\n\n#plot the results with respect to the dt values\n\n# Create traces for each cost component\ntrace_capex = go.Scatter(x=dt_1, y=CAPEXv_1, mode='lines', name='CAPEX', line=dict(color='black'))\ntrace_opex_france = go.Scatter(x=dt_1, y=OPEX_frv_1, mode='lines', name='OPEX (France)', line=dict(color='blue'))\ntrace_opex_germany = go.Scatter(x=dt_1, y=OPEX_gerv_1, mode='lines', name='OPEX (Germany)', line=dict(color='red'))\ntrace_totex_france = go.Scatter(x=dt_1, y=TOTEX_frv_1, mode='lines', name='TOTEX (France)', line=dict(color='blue', dash='dash'))\ntrace_totex_germany = go.Scatter(x=dt_1, y=TOTEX_gerv_1, mode='lines', name='TOTEX (Germany)', line=dict(color='red', dash='dash'))\n\n# Create layout\nlayout = go.Layout(\n    title='Costs vs dTmin',\n    xaxis=dict(title='dTmin (K)'),\n    yaxis=dict(title='Costs (€)'),\n    legend=dict(x=0, y=-0.2, traceorder='normal', orientation='h'),\n    showlegend=True\n)\n\n# Create figure\nfig = go.Figure(data=[trace_capex, trace_opex_france, trace_opex_germany, trace_totex_france, trace_totex_germany], layout=layout)\n\n# Mark the minima points\nmin_index_fr_1 = np.argmin(TOTEX_frv_1)\nfig = fig.add_trace(go.Scatter(x=[dt_1[min_index_fr_1]], y=[TOTEX_frv_1[min_index_fr_1]], mode='markers', marker=dict(color='blue'), name='Min TOTEX (France)'))\n\nmin_index_ger_1 = np.argmin(TOTEX_gerv_1)\nfig = fig.add_trace(go.Scatter(x=[dt_1[min_index_ger_1]], y=[TOTEX_gerv_1[min_index_ger_1]], mode='markers', marker=dict(color='red'), name='Min TOTEX (Germany)'))\n\n# Show the figure\nfig.show()\n\n\n\n                        \n                                            \n\n\nCode\ndtmin_fr_opt_1 = dt_1[min_index_fr_1]\ndtmin_ger_opt_1 = dt_1[min_index_ger_1]\narea_fr_opt_1 = Areav_1[min_index_fr_1]\narea_ger_opt_1 = Areav_1[min_index_ger_1]\nCAPEX_fr_opt_1 = CAPEXv_1[min_index_fr_1]\nCAPEX_ger_opt_1 = CAPEXv_1[min_index_ger_1]\nOPEX_fr_opt_1 = OPEX_frv_1[min_index_fr_1]\nOPEX_ger_opt_1 = OPEX_gerv_1[min_index_ger_1]\nTOTEX_fr_opt_1 = TOTEX_frv_1[min_index_fr_1]\nTOTEX_ger_opt_1 = TOTEX_gerv_1[min_index_ger_1]\n\nPast1_opt_fr_sc2 = pd.DataFrame({'dTmin_fr[K]': dtmin_fr_opt_1, 'Area_fr[m^2]': area_fr_opt_1, 'CAPEX_fr[€/yr]': CAPEX_fr_opt_1, 'OPEX_fr[€/yr]': OPEX_fr_opt_1, 'TOTEX_fr[€/yr]': TOTEX_fr_opt_1}, index=[0])\nPast1_opt_fr_sc2 = Past1_opt_fr_sc2.round(2)\nHTML(Past1_opt_fr_sc2.to_html(index=False))\n\n\n\n\n\ndTmin_fr[K]\nArea_fr[m^2]\nCAPEX_fr[€/yr]\nOPEX_fr[€/yr]\nTOTEX_fr[€/yr]\n\n\n\n\n63.13\n8.67\n23212.4\n476363.24\n499575.65\n\n\n\n\n\nCode\nPast1_opt_ger_sc2 = pd.DataFrame({'dTmin_ger[K]': dtmin_ger_opt_1, 'Area_ger[m^2]': area_ger_opt_1, 'CAPEX_ger[€/yr]': CAPEX_ger_opt_1, 'OPEX_ger[€/yr]': OPEX_ger_opt_1, 'TOTEX_ger[€/yr]': TOTEX_ger_opt_1}, index=[0])\nPast1_opt_ger_sc2 = Past1_opt_ger_sc2.round(2)\nHTML(Past1_opt_ger_sc2.to_html(index=False))\n\n\n\n\n\ndTmin_ger[K]\nArea_ger[m^2]\nCAPEX_ger[€/yr]\nOPEX_ger[€/yr]\nTOTEX_ger[€/yr]\n\n\n\n\n44.06\n85.54\n237426.65\n594867.77\n832294.42\n\n\n\n\n\nCode\n####################################\n############## PAST5 ##############\n####################################\n\nT1_prime_1_fr = Dtmin(dtmin_fr_opt_1, T1_1, T1v_1, T2v_1, T2_1, m1_1, m2_1, cp1_1, cp2_1, 'left', 1)[6]\nT1_5 = T1_prime_1_fr #J'ai checké c'est 67°C donc bien inferieur au 70°C de T_hin=70° de past1 et bien inferieur au T_hint=75°C de past5\n#Would be the same if we used dtmin_ger_opt_1 since T1_prime_1_ger = T1_prime_1_fr = T1v.max()\n\n\nT2_5 = 348\n\np1_1 = 100000\n\nm1_5 = 0.48\nm2_5 = 0.55\n\nState_Cold_1_5 = mixture(T=T1_5, P=p1_5, frac_water=0.65, frac_fat=0.35)\nState_Cold_2_5 = mixture(T=T2_5, P=p1_5, frac_water=0.65, frac_fat=0.35)\n\nh1_5 = State_Cold_1_5[\"enthalpy\"] * m1_5  #from mixture with dry = 35% and wet = 65%\nh2_5 = State_Cold_2_5[\"enthalpy\"] * m2_5\n\ncp1_5 = State_Cold_1_5[\"cpmass\"]\ncp2_5 = State_Cold_2_5[\"cpmass\"]\n\nslope1_5 = 1/(m1_5*cp1_5)\nslope2_5 = 1/(m2_5*cp2_5)\n\n#Plot the two lines with T on the y-axis and h on the x-axis\n#h is the enthalpy of the stream between h1 and h2\nN = 100\nh_5 = np.linspace(h1_5, h2_5, N)\n\nC1_5 = T1_5 - slope1_5*h1_5\nT1v_5 = slope1_5*h_5 + C1_5\n\nC2_5 = T2_5 - slope2_5*h2_5\nT2v_5 = slope2_5*h_5 + C2_5\n\n\n# Create trace for Cold Stream\ntrace_cold = go.Scatter(x=h_5, y=T1v_5, mode='lines', name='Cold Stream')\n# Create trace for Hot Stream\ntrace_hot = go.Scatter(x=h_5, y=T2v_5, mode='lines', name='Hot Stream')\n# Create layout\nlayout = go.Layout(\n    title='Temperature vs Enthalpy',\n    xaxis=dict(title='Enthalpy (J)'),\n    yaxis=dict(title='Temperature (K)'),\n    legend=dict(x=0, y=1, traceorder='normal'),\n    showlegend=True\n)\n# Create figure\nfig = go.Figure(data=[trace_cold, trace_hot], layout=layout)\n# Plot the vertical line at dTmin\ndt_5 = T2v_5 - T1v_5\ndTmin_5 = dt_5.min()\nmin_index_5 = dt_5.argmin()\nfig.add_shape(\n    type='line',\n    x0=h_5[min_index_5],\n    x1=h_5[min_index_5],\n    y0=min(T1v_5[min_index_5], T2v_5[min_index_5]),\n    y1=max(T1v_5[min_index_5], T2v_5[min_index_5]),\n    line=dict(color='red', dash='dash')\n)\n\n\n\n                        \n                                            \n\n\nCode\nprint('dTmin =', round(dTmin_5, 3), 'K at h =', round(h_5[min_index_5], 3), 'kJ/kg')\n\n\ndTmin = 1.624 K at h = -21384.368 kJ/kg\n\n\nCode\n#Redo the CAPEX/OPEX/TOTEX for different dT and plot the results\n\nCAPEXv_5 = []\nOPEX_frv_5 = []\nOPEX_gerv_5 = []\nTOTEX_frv_5 = []\nTOTEX_gerv_5 = []\nAreav_5 = []\n\ndt_5 = np.linspace(0.1, 30, 300)\n\nfor t in dt_5:\n    CAPEX_5, OPEX_fr_5, OPEX_ger_5, TOTEX_fr_5, TOTEX_ger_5, Area_5 = Dtmin(t, T1_5, T1v_5, T2v_5, T2_5, m1_5, m2_5, cp1_5, cp2_5, 'right', 5)[0:6]\n    CAPEXv_5.append(CAPEX_5)\n    OPEX_frv_5.append(OPEX_fr_5)\n    OPEX_gerv_5.append(OPEX_ger_5)\n    TOTEX_frv_5.append(TOTEX_fr_5)\n    TOTEX_gerv_5.append(TOTEX_ger_5)\n    Areav_5.append(Area_5)\n\n#plot the results with respect to the dt values\n\n# Create traces for each cost component\ntrace_capex = go.Scatter(x=dt_5, y=CAPEXv_5, mode='lines', name='CAPEX', line=dict(color='black'))\ntrace_opex_france = go.Scatter(x=dt_5, y=OPEX_frv_5, mode='lines', name='OPEX (France)', line=dict(color='blue'))\ntrace_opex_germany = go.Scatter(x=dt_5, y=OPEX_gerv_5, mode='lines', name='OPEX (Germany)', line=dict(color='red'))\ntrace_totex_france = go.Scatter(x=dt_5, y=TOTEX_frv_5, mode='lines', name='TOTEX (France)', line=dict(color='blue', dash='dash'))\ntrace_totex_germany = go.Scatter(x=dt_5, y=TOTEX_gerv_5, mode='lines', name='TOTEX (Germany)', line=dict(color='red', dash='dash'))\n\n# Create layout\nlayout = go.Layout(\n    title='Costs vs dTmin',\n    xaxis=dict(title='dTmin (K)'),\n    yaxis=dict(title='Costs (€)'),\n    legend=dict(x=0, y=-0.2, traceorder='normal', orientation='h'),\n    showlegend=True\n)\n\n# Create figure\nfig = go.Figure(data=[trace_capex, trace_opex_france, trace_opex_germany, trace_totex_france, trace_totex_germany], layout=layout)\n\n# Mark the minima points\nmin_index_fr_5 = np.argmin(TOTEX_frv_5)\nfig = fig.add_trace(go.Scatter(x=[dt_5[min_index_fr_5]], y=[TOTEX_frv_5[min_index_fr_5]], mode='markers', marker=dict(color='blue'), name='Min TOTEX (France)'))\n\nmin_index_ger_5 = np.argmin(TOTEX_gerv_5)\nfig = fig.add_trace(go.Scatter(x=[dt_5[min_index_ger_5]], y=[TOTEX_gerv_5[min_index_ger_5]], mode='markers', marker=dict(color='red'), name='Min TOTEX (Germany)'))\n\n# Show the figure\nfig.show()\n\n\n\n                        \n                                            \n\n\nCode\n#print the area, dt, CAPEX, OPEX, TOTEX for the minimum TOTEX\n\ndtmin_fr_opt_5 = dt_5[min_index_fr_5]\ndtmin_ger_opt_5 = dt_5[min_index_ger_5]\narea_fr_opt_5 = Areav_5[min_index_fr_5]\narea_ger_opt_5 = Areav_5[min_index_ger_5]\nCAPEX_fr_opt_5 = CAPEXv_5[min_index_fr_5]\nCAPEX_ger_opt_5 = CAPEXv_5[min_index_ger_5]\nOPEX_fr_opt_5 = OPEX_frv_5[min_index_fr_5]\nOPEX_ger_opt_5 = OPEX_gerv_5[min_index_ger_5]\nTOTEX_fr_opt_5 = TOTEX_frv_5[min_index_fr_5]\nTOTEX_ger_opt_5 = TOTEX_gerv_5[min_index_ger_5]\n\nPast5_opt_fr_sc2 = pd.DataFrame({'dTmin_fr[K]': dtmin_fr_opt_5, 'Area_fr[m^2]': area_fr_opt_5, 'CAPEX_fr[€/yr]': CAPEX_fr_opt_5, 'OPEX_fr[€/yr]': OPEX_fr_opt_5, 'TOTEX_fr[€/yr]': TOTEX_fr_opt_5}, index=[0])\nPast5_opt_fr_sc2 = Past5_opt_fr_sc2.round(2)\nHTML(Past5_opt_fr_sc2.to_html(index=False))\n\n\n\n\n\ndTmin_fr[K]\nArea_fr[m^2]\nCAPEX_fr[€/yr]\nOPEX_fr[€/yr]\nTOTEX_fr[€/yr]\n\n\n\n\n6.3\n5.21\n13822.68\n43807.11\n57629.8\n\n\n\n\n\nCode\nPast5_opt_ger_sc2 = pd.DataFrame({'dTmin_ger[K]': dtmin_ger_opt_5, 'Area_ger[m^2]': area_ger_opt_5, 'CAPEX_ger[€/yr]': CAPEX_ger_opt_5, 'OPEX_ger[€/yr]': OPEX_ger_opt_5, 'TOTEX_ger[€/yr]': TOTEX_ger_opt_5}, index=[0])\nPast5_opt_ger_sc2 = Past5_opt_ger_sc2.round(2)\nHTML(Past5_opt_ger_sc2.to_html(index=False))\n\n\n\n\n\ndTmin_ger[K]\nArea_ger[m^2]\nCAPEX_ger[€/yr]\nOPEX_ger[€/yr]\nTOTEX_ger[€/yr]\n\n\n\n\n6.3\n5.21\n13822.68\n70637.75\n84460.43\n\n\n\n\n\nCode\n####################################\n############## PAST1 + PAST5 ##############\n####################################\n\n#Summarize the value for the overall optimum CAPEX, OPEX, and TOTEX of the two pasteurizers\n\n\nCAPEX_fr_opt_15 = CAPEX_fr_opt_1 + CAPEX_fr_opt_5\nCAPEX_ger_opt_15 = CAPEX_ger_opt_1 + CAPEX_ger_opt_5\nOPEX_fr_opt_15 = OPEX_fr_opt_1 + OPEX_fr_opt_5\nOPEX_ger_opt_15 = OPEX_ger_opt_1 + OPEX_ger_opt_5\nTOTEX_fr_opt_15 = TOTEX_fr_opt_1 + TOTEX_fr_opt_5\nTOTEX_ger_opt_15 = TOTEX_ger_opt_1 + TOTEX_ger_opt_5\n\nOverall_opt_fr_sc2 = pd.DataFrame({'CAPEX_tot_fr[€/yr]': CAPEX_fr_opt_15, 'OPEX_tot_fr[€/yr]': OPEX_fr_opt_15, 'TOTEX_tot_fr[€/yr]': TOTEX_fr_opt_15}, index=[0])\nOverall_opt_fr_sc2 = Overall_opt_fr_sc2.round(2)\nHTML(Overall_opt_fr_sc2.to_html(index=False))\n\n\n\n\n\nCAPEX_tot_fr[€/yr]\nOPEX_tot_fr[€/yr]\nTOTEX_tot_fr[€/yr]\n\n\n\n\n37035.09\n520170.36\n557205.44\n\n\n\n\n\nCode\nOverall_opt_ger_sc2 = pd.DataFrame({'CAPEX_tot_ger[€/yr]': CAPEX_ger_opt_15, 'OPEX_tot_ger[€/yr]': OPEX_ger_opt_15, 'TOTEX_tot_ger[€/yr]': TOTEX_ger_opt_15}, index=[0])\nOverall_opt_ger_sc2 = Overall_opt_ger_sc2.round(2)\nHTML(Overall_opt_ger_sc2.to_html(index=False))\n\n\n\n\n\nCAPEX_tot_ger[€/yr]\nOPEX_tot_ger[€/yr]\nTOTEX_tot_ger[€/yr]\n\n\n\n\n251249.34\n665505.52\n916754.85\n\n\n\n\n\n\n\n4.1.3 Past 5 + recovery HEX\nIn this scenario we have to estimate if it is worth to recover heat from past5 and use it to preheat another HX in this pasteurization stage. Past5 is already used to preheat past6 (thanks to crpast_a flow which then becomes cr_past_x). Thus there is no improvement possible here. Then past1 entering flow (past_c) is already preheated by past 2 and past 3. Remaining HX are for cooling and thus we don’t want to preheat their incoming flows.\nIt appears heat recovery is already well used in this system and we will assume it is not worth to divert hot flows from past5 to preheat another flow.\n\n\n4.1.4 Cleaning in Place\nNow we will only focus on another part of the process (the cleaning in place) and we will try to optimize the heat recovery. We look for the heat exchanger in this process. There is one used to heat thanks to use of steam between flows CIP2 and CIP3/10, and there is one used to cool with glycolic water between flows CIP6 and CIP7. We could try to reduce both heat and cooling demand by connecting these two HX differently. In chapter 2 when deermining heat and mass balances, we had determined the following relations between the flows temperatures: - T_cip6=75°C &gt; T_cip2=60°C\nWe could thus imagine a system where CIP6 flow is first used to preheat CIP2 to CIP2’ (with T_cip2’ &gt; T_cip2) and the exiting flows called CIP6’ (such that T_cip6’&lt; T_cip6) is then used to be cooled where CIP6 was previously. Hence we would have a system with less cooling required since T_cip6’&lt; T_cip6, and with also less heating required since T_cip2’ &gt; T_cip2.\nLet’s try to apply the method used for the pasterization:\n\n\nCode\nfrom pyxosmose.state import State\n\nT1_cip = 333  #T_cip2 in CH2\nT2_cip = 348  #T_cip6 in CH2\n\np1_cip = 100000\n\nm1_cip = 4 #m_cip2 in CH2\nm2_cip = 1.2 #m_cip6 in CH2\n\n\n\nState_Cold_1_cip = State(pair='TP', fluid='water', temperature=T1_cip, pressure=p1_cip)\nState_Cold_1_cip.StateCalc()\nState_Cold_1_cip = State_Cold_1_cip.__dict__ \n\nState_Cold_2_cip = State(pair='TP', fluid='water', temperature=T2_cip, pressure=p1_cip)\nState_Cold_2_cip.StateCalc()\nState_Cold_2_cip = State_Cold_2_cip.__dict__\n\nh1_cip = State_Cold_1_cip[\"enthalpy\"] * m1_cip  #from mixture with dry = 35% and wet = 65%\nh2_cip = State_Cold_2_cip[\"enthalpy\"] * m2_cip\n\ncp1_cip = State_Cold_1_cip[\"cpmass\"]\ncp2_cip = State_Cold_2_cip[\"cpmass\"]\n\nslope1_cip = 1/(m1_cip*cp1_cip)\nslope2_cip = 1/(m2_cip*cp2_cip)\n\n#Plot the two lines with T on the y-axis and h on the x-axis\n#h is the enthalpy of the stream between h1 and h2\nN = 100\nh_cip = np.linspace(h1_cip, h2_cip, N)\n\nC1_cip = T1_cip - slope1_cip*h1_cip\nT1v_cip = slope1_cip*h_cip + C1_cip\n\nC2_cip = T2_cip - slope2_cip*h2_cip\nT2v_cip = slope2_cip*h_cip + C2_cip\n\n\n# Create trace for Cold Stream\ntrace_cold = go.Scatter(x=h_cip, y=T1v_cip, mode='lines', name='Cold Stream')\n# Create trace for Hot Stream\ntrace_hot = go.Scatter(x=h_cip, y=T2v_cip, mode='lines', name='Hot Stream')\n# Create layout\nlayout = go.Layout(\n    title='Temperature vs Enthalpy',\n    xaxis=dict(title='Enthalpy (J)'),\n    yaxis=dict(title='Temperature (K)'),\n    legend=dict(x=0, y=1, traceorder='normal'),\n    showlegend=True\n)\n# Create figure\nfig = go.Figure(data=[trace_cold, trace_hot], layout=layout)\n# Plot the vertical line at dTmin\ndt_cip = T2v_cip - T1v_cip\ndTmin_cip = dt_cip.min()\nmin_index_cip = dt_cip.argmin()\nfig.add_shape(\n    type='line',\n    x0=h_cip[min_index_cip],\n    x1=h_cip[min_index_cip],\n    y0=min(T1v_cip[min_index_cip], T2v_cip[min_index_cip]),\n    y1=max(T1v_cip[min_index_cip], T2v_cip[min_index_cip]),\n    line=dict(color='red', dash='dash')\n)\n\n\n\n                        \n                                            \n\n\nCode\nprint('dTmin =', round(dTmin_cip, 3), 'K at h =', round(h_cip[min_index_cip], 3), 'kJ/kg')\n\n\ndTmin = 52.417 K at h = 376140.608 kJ/kg\n\n\nCode\n#Redo the CAPEX/OPEX/TOTEX for different dT and plot the results\n\nCAPEXv_cip = []\nOPEX_frv_cip = []\nOPEX_gerv_cip = []\nTOTEX_frv_cip = []\nTOTEX_gerv_cip = []\nAreav_cip = []\n\ndt_cip = np.linspace(0.1, 30, 300)\n\nfor t in dt_cip:\n    CAPEX_cip, OPEX_fr_cip, OPEX_ger_cip, TOTEX_fr_cip, TOTEX_ger_cip, Area_cip = Dtmin(t, T1_cip, T1v_cip, T2v_cip, T2_cip, m1_cip, m2_cip, cp1_cip, cp2_cip, 'left', 'cip')[0:6]\n    CAPEXv_cip.append(CAPEX_cip)\n    OPEX_frv_cip.append(OPEX_fr_cip)\n    OPEX_gerv_cip.append(OPEX_ger_cip)\n    TOTEX_frv_cip.append(TOTEX_fr_cip)\n    TOTEX_gerv_cip.append(TOTEX_ger_cip)\n    Areav_cip.append(Area_cip)\n\n\n&lt;string&gt;:19: RuntimeWarning:\n\ninvalid value encountered in scalar divide\n\n&lt;string&gt;:34: RuntimeWarning:\n\ninvalid value encountered in log\n\n\nCode\n#plot the results with respect to the dt values\n\n# Create traces for each cost component\ntrace_capex = go.Scatter(x=dt_cip, y=CAPEXv_cip, mode='lines', name='CAPEX', line=dict(color='black'))\ntrace_opex_france = go.Scatter(x=dt_cip, y=OPEX_frv_cip, mode='lines', name='OPEX (France)', line=dict(color='blue'))\ntrace_opex_germany = go.Scatter(x=dt_cip, y=OPEX_gerv_cip, mode='lines', name='OPEX (Germany)', line=dict(color='red'))\ntrace_totex_france = go.Scatter(x=dt_cip, y=TOTEX_frv_cip, mode='lines', name='TOTEX (France)', line=dict(color='blue', dash='dash'))\ntrace_totex_germany = go.Scatter(x=dt_cip, y=TOTEX_gerv_cip, mode='lines', name='TOTEX (Germany)', line=dict(color='red', dash='dash'))\n\n# Create layout\nlayout = go.Layout(\n    title='Costs vs dTmin',\n    xaxis=dict(title='dTmin (K)'),\n    yaxis=dict(title='Costs (€)'),\n    legend=dict(x=0, y=-0.2, traceorder='normal', orientation='h'),\n    showlegend=True\n)\n\n# Create figure\nfig = go.Figure(data=[trace_capex, trace_opex_france, trace_opex_germany, trace_totex_france, trace_totex_germany], layout=layout)\n\n# Mark the minima points for both France and Germany\nmin_index_fr_cip = np.argmin(TOTEX_frv_cip)\nfig = fig.add_trace(go.Scatter(x=[dt_cip[min_index_fr_cip]], y=[TOTEX_frv_cip[min_index_fr_cip]], mode='markers', marker=dict(color='blue'), name='Min TOTEX (France)'))\n\nmin_index_ger_cip = np.argmin(TOTEX_gerv_cip)\nfig = fig.add_trace(go.Scatter(x=[dt_cip[min_index_ger_cip]], y=[TOTEX_gerv_cip[min_index_ger_cip]], mode='markers', marker=dict(color='red'), name='Min TOTEX (Germany)'))\n\n# Show the figure\nfig.show()\n\n\n\n                        \n                                            \n\n\nCode\n#print the optimum values for dt, area, CAPEX, OPEX, TOTEX for both France and Germany (NB: even if we have the same CAPEX fct for both countries, the optimum CAPEX will be different in both countries because of the electricity/gas rate)\n\ndtmin_fr_opt_cip = dt_cip[min_index_fr_cip]\ndtmin_ger_opt_cip = dt_cip[min_index_ger_cip]\narea_fr_opt_cip = Areav_cip[min_index_fr_cip]\narea_ger_opt_cip = Areav_cip[min_index_ger_cip]\nCAPEX_fr_opt_cip = CAPEXv_cip[min_index_fr_cip]\nCAPEX_ger_opt_cip = CAPEXv_cip[min_index_ger_cip]\nOPEX_fr_opt_cip = OPEX_frv_cip[min_index_fr_cip]\nOPEX_ger_opt_cip = OPEX_gerv_cip[min_index_ger_cip]\nTOTEX_fr_opt_cip = TOTEX_frv_cip[min_index_fr_cip]\nTOTEX_ger_opt_cip = TOTEX_gerv_cip[min_index_ger_cip]\n\nCIP_opt_fr = pd.DataFrame({'dTmin_fr[K]': dtmin_fr_opt_cip, 'Area_fr[m^2]': area_fr_opt_cip, 'CAPEX_fr[€/yr]': CAPEX_fr_opt_cip, 'OPEX_fr[€/yr]': OPEX_fr_opt_cip, 'TOTEX_fr[€/yr]': TOTEX_fr_opt_cip}, index=[0])\nCIP_opt_fr = CIP_opt_fr.round(2)\nHTML(CIP_opt_fr.to_html(index=False))\n\n\n\n\n\ndTmin_fr[K]\nArea_fr[m^2]\nCAPEX_fr[€/yr]\nOPEX_fr[€/yr]\nTOTEX_fr[€/yr]\n\n\n\n\n15.0\nNaN\nNaN\n324824.01\nNaN\n\n\n\n\n\nCode\nCIP_opt_ger = pd.DataFrame({'dTmin_ger[K]': dtmin_ger_opt_cip, 'Area_ger[m^2]': area_ger_opt_cip, 'CAPEX_ger[€/yr]': CAPEX_ger_opt_cip, 'OPEX_ger[€/yr]': OPEX_ger_opt_cip, 'TOTEX_ger[€/yr]': TOTEX_ger_opt_cip}, index=[0])\nCIP_opt_ger = CIP_opt_ger.round(2)\nHTML(CIP_opt_ger.to_html(index=False))\n\n\n\n\n\ndTmin_ger[K]\nArea_ger[m^2]\nCAPEX_ger[€/yr]\nOPEX_ger[€/yr]\nTOTEX_ger[€/yr]\n\n\n\n\n15.0\nNaN\nNaN\n401274.03\nNaN\n\n\n\n\n\n\n\n4.1.5 To be done:\nBy comparing these costs with the one computed in Chapter 3 (Energy Bill), we can see…. (TODO for all scenarios)"
  },
  {
    "objectID": "04.00-HeatRecovery.html#minimum-energy-requirement",
    "href": "04.00-HeatRecovery.html#minimum-energy-requirement",
    "title": "4  Pinch analysis",
    "section": "4.2 Minimum energy requirement",
    "text": "4.2 Minimum energy requirement\nThe minimum energy requirement, including both heat and cooling demand, can be determined through the application of pinch analysis. \n\n\n\n\n\n4.2.1 Introduction to Pinch Analysis\nWhen designing a process, engineers primarily address three concerns: they aim to recover process heat wherever possible, maximize process-to-process exchanges, and minimize the Heat Exchanger Network (HEN).\nTo achieve this, H-T diagrams are employed to determine the minimal temperature difference between hot and cold exchanges, defining it as the pinch point. Subsequently, the process is partitioned into cold and hot areas, both in relation to the pinch point.\nThe fundamental concept of pinch analysis is to optimize heat exchanges between these two areas.\nThis analysis unfolds in three steps: first, hot and cold streams are defined; second, the minimum energy requirement is computed (the target step); and finally, the synthesis step is executed by enhancing the HEN.\nThis methodology is thus known as the pinch point analysis, and we will show the results of this analysis in the next part of this report.\n\n\n4.2.2 Analysis Results\nIn this section we will show the results of our pinch analysis. First we will show the composite curves (Fig. 1) and the grand composite curve (Fig. 2).\nFrom the composite curves we are then able to extrapolate the energy requirements, the heat recovery and the utilities, by separating the graph in three portions with two green dotted lines, showing the boundaries of the utilities and the heat recovery.\nWe can also use the graph of the grand composite curve to determine the temperature of the pinch points. These are the points where the heat load is equal to 0, meaning that the heats of the corrected cold and hot streams are the same in these points. We do not consider the two points at the edges of the temperature values since they’re not pinch points.\nWe will start by showing the composite curves first:\n\n\nCode\nlibrary(jsonlite)\npfilename&lt;-\"codes_02_heat_recovery/result/brewery-1.json\"\ndata &lt;- fromJSON(pfilename, flatten=FALSE)\ntotex&lt;-data$results$KPIs$totalcost\ncapex&lt;-data$results$KPIs$capex\nopex&lt;-data$results$KPIs$opex\n\ncosts&lt;-data.frame(totex, opex, capex)\n\n\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport json\nimport numpy as np\n\nplt.switch_backend('agg')\n\n# read json for heat integration data\nfile_name = open('codes_02_heat_recovery/result/brewery-1.json')\ninteg = json.loads(file_name.read())\n\n# we used .keys() and json-reader to locate the data of interest (hot and cold composite curves)\nhotcc = integ[\"results\"][\"graph\"][0][0][1][\"data\"][0][\"curve\"]\ncoldcc = integ[\"results\"][\"graph\"][0][0][1][\"data\"][1][\"curve\"]\n\n# extract the temperature (T in Kelvin) and heat (Q in kW)\nT_hc = [i[\"T\"] for i in hotcc]\nQ_hc = [i[\"Q\"] for i in hotcc]\nT_cc = [i[\"T\"] for i in coldcc]\nQ_cc = [i[\"Q\"] for i in coldcc]\n\n# compute the shifted carnot factor (1 - T0/T) and Treference = 298.15K\nTref = 298.15 \nca_hc = [(1-Tref/i) for i in T_hc]\nca_cc = [(1-Tref/i) for i in T_cc]\n\n# compute back the original carnot factors given a deltaT_min\ndeltaT_min = 40\nT_hc_ori = [(i+deltaT_min/2) for i in T_hc]\nT_cc_ori = [(i-deltaT_min/2) for i in T_cc]\nca_hc_ori = [(1-298.15/i) for i in T_hc_ori]\nca_cc_ori = [(1-298.15/i) for i in T_cc_ori]\n\n# prepare the second y-axis for plotting\n# the minim carnot value is extracted from the original cooling. Round it to the lowest .0\n# the maximum carnot carnot value is extracted from the original heating. Round it to the highest .0\nca_min = round(min(ca_cc_ori) - 0.05, 1)\nca_max = round(max(ca_hc_ori) + 0.05, 1)\n# generate an array with the carnot list from min to max\nca_values = np.arange(ca_min, ca_max, 0.2)\n# compute the corresponding temperature values in celcius\nTref_ce = 298.15\nT_ce = [int(Tref_ce/(1-i) - 273.15) for i in ca_values]\n\n# plot the composite curves\nfigure, ax = plt.subplots(figsize = (8,6))\n\n# both cold curves (blue): dashed --&gt; shifted, solid --&gt; original\nax.plot(Q_cc, ca_cc, \"--b\")\nax.plot(Q_cc, ca_cc_ori, \"-b\")\n# both hot curves (red): dashed --&gt; shifted, solid --&gt; original\nax.plot(Q_hc, ca_hc, \"--r\")\nax.plot(Q_hc, ca_hc_ori, \"-r\")\n# fill the area between the original and shifted curves\nax.fill_between(Q_cc, ca_cc_ori, ca_cc, color=\"blue\", alpha=0.25)\nax.fill_between(Q_hc, ca_hc, ca_hc_ori, color=\"red\", alpha=0.25)\n\n# add the lables and title\nax.set_xlabel('$Heat \\ Load \\ (kW)$', labelpad=12)\nax.set_ylabel('$Carnot \\ Factor \\ (1 - T_{0}/T)$')\nax.set_title('$Composite \\ Curves$')\nax.legend([\"Corrected Cold Composite Curve\", \"Cold Composite Curve\", \"Corrected Hot Composite Curve\", \"Hot Composite Curve\"])\nax.set_ybound(ca_min, ca_max)\n\n# secondary axis. In this case we don't plot anything, we simply set the secondary axis ticks\nax2 =ax.twinx()\nax2.set_yticks(np.arange(0, len(T_ce), 1), T_ce)\nax2.set_ylabel('$Temperature \\ (\\u00b0C)$', labelpad=10)\n\nplt.axvline(x=24946.177132, color=\"green\", linestyle=\"--\")\nplt.axvline(x=2975.059841, color=\"green\", linestyle=\"--\")\n\nplt.show()\n\n\n\n\n\nFig. 1: Composite Curves\n\n\n\n\nCode\n\n# save the plot as a png\nfigure.savefig(\"composite_curves.png\", format=\"png\", dpi=600)\n\n\nHere is the grand composite curve:\n\n\nCode\nQ_gcc = np.zeros(len(Q_cc))\n\nfor i in range(len(Q_cc)):\n  Q_gcc[i] = Q_cc[i] - Q_hc[i]  \n\nfor i in range(len(T_hc)):\n  T_hc[i] = T_hc[i] - 273.15\n\nfigure, ax = plt.subplots(figsize = (8,6))\n\nax.plot(Q_gcc, T_hc, \"-g\")\nplt.axhline(y=0, color='black', linestyle='--')\n\n\nax.set_xlabel('$Heat \\ Load \\ (kW)$', labelpad=12)\nax.set_ylabel('$Temperature \\ (°C)$')\nax.set_title('$Grand \\ Composite \\ Curve$')\nax.legend([\"Grand Composite Curve\"])\nax.set_ybound(-100, 1200)\n\nplt.show()\n\n\n\n\n\nFig. 2: Grand Composite Curve\n\n\n\n\nCode\n\nHeat_inter = []\nintersections = []\nfor i in range(len(Q_gcc)):\n  if (Q_gcc[i]&lt;=10):\n    if (T_hc[i]&gt;=0 and T_hc[i]&lt;=1000):\n      intersections.append(T_hc[i])\n      Heat_inter.append(Q_gcc[i])\n#print(\"We can observe two pinch points at the temperatures:\", intersections, \" (°C)\")\n#print(np.max(ca_hc_ori))\n#print(np.min(ca_cc_ori))\n\nupper_bound = 0\nlower_bound = 5000\nfor i in range(len(Q_hc)):\n  if (ca_hc_ori[i] &lt; (np.max(ca_hc_ori)) and Q_hc[i] &gt; upper_bound):\n    upper_bound = Q_hc[i]\n  if (ca_cc_ori[i] &gt; np.min(ca_cc_ori) and Q_cc[i] &lt; lower_bound):\n    lower_bound = Q_cc[i]\n#print(lower_bound, upper_bound)\n#print(\"We find that the maximum heat recovery potential is equal to\", np.round(upper_bound - lower_bound, 2), \" W.\")\n\n\nIn the next tables we will show the temperatures of the pinch points and the energy requirements and heat recovery:\n\n\nCode\nimport pandas as pd\nimport numpy as np\nfrom IPython.display import display, HTML\n\n\ncold_utilities = lower_bound\ntotal_w = 0\n\nfor i in range(len(Q_cc)):\n  if ((ca_cc_ori[i] &gt; 0.4) and (Q_cc[i] &gt; total_w)):\n    total_w = Q_cc[i]\n\n\nhot_utilities = total_w - upper_bound\n\n#print(\"The cold utilities require\", cold_utilities, \"W and the hot utilities need\", hot_utilities, \"W of energy. In total, the minimum energy requirements are of\", (cold_utilities+hot_utilities),\"W.\")\n\n\n\n\ndata_pinch_points = {'Pinch Points': ['Pinch Point 1', 'Pinch Point 2'],\n        'Temperature (°C)': [ intersections[0], intersections[1]]}\n\ndfs = pd.DataFrame(data_pinch_points)\ndfs = dfs.set_index('Pinch Points')\ndfs = dfs.round(2)\nHTML(dfs.to_html())\n\n\n\n\n\n\nTemperature (°C)\n\n\nPinch Points\n\n\n\n\n\nPinch Point 1\n17.00\n\n\nPinch Point 2\n33.01\n\n\n\n\n\nWe can check that the heat load at these points is indeed 0 W by extracting its value at these points:\n\n\nCode\ndata_pinch_points = {'Pinch Points': ['Pinch Point 1', 'Pinch Point 2'],\n        'Heat (W)': [ Heat_inter[0], Heat_inter[1]]}\n\ndfs = pd.DataFrame(data_pinch_points)\ndfs = dfs.set_index('Pinch Points')\nHTML(dfs.to_html())\n\n\n\n\n\n\nHeat (W)\n\n\nPinch Points\n\n\n\n\n\nPinch Point 1\n3.902001e-07\n\n\nPinch Point 2\n5.279999e-07\n\n\n\n\n\nThese values can indeed be approximated to 0 W.\nWe are also able to compute the energy requirements and maximum heat recovery:\n\n\nCode\ndata_heat_recovery = {'Information': ['Cold Utilities', 'Hot Utilities', 'Minimum Energy Requirements', 'Maximum Heat Recovery Potential'],\n        'Heat (W)': [cold_utilities, hot_utilities, cold_utilities+hot_utilities, np.round(upper_bound - lower_bound, 2)]}\n\ndfs = pd.DataFrame(data_heat_recovery)\ndfs = dfs.set_index('Information')\ndfs = dfs.round(2)\nHTML(dfs.to_html())\n\n\n\n\n\n\nHeat (W)\n\n\nInformation\n\n\n\n\n\nCold Utilities\n2975.06\n\n\nHot Utilities\n2566.39\n\n\nMinimum Energy Requirements\n5541.45\n\n\nMaximum Heat Recovery Potential\n21971.12"
  },
  {
    "objectID": "05.00-HeatExhangerNetwork.html#identification-of-penalizing-heat-exchangers",
    "href": "05.00-HeatExhangerNetwork.html#identification-of-penalizing-heat-exchangers",
    "title": "5  Heat Exchanger Network design",
    "section": "5.1 Identification of Penalizing Heat Exchangers",
    "text": "5.1 Identification of Penalizing Heat Exchangers\n\nThanks to the pinch analysis effectuated in the previous section it is possible to identify penalizing heat exchangers. There are four types of penalizing heat exchangers: - A cold utility cooling down a hot stream above the pinch - A hot utility heating up a cold stream below the pinch - A heat exchanger heating up a cold stream under the pinch using a hot stream above the pinch - A mixer where the fluids it is mixing are not on the same side of the pinch point, i.e. the cooler fluid intake is below the pinch and the warmer fluid intake is above the pinch\nThanks to having calculated the pinch point at 67.5 °C in the previous section, it is now easy to find the penalizing heat exchangers in each section.\nFurthermore, it is possible to calculate the penalty caused by each penalizing heat exchanger, as it is simply the amount of heat utilized by said exchanger.\nThe Wastewater and sludge production section will be skipped as it does not utilize any heat exchangers.\nASK IF PENALIZING EXCHANGERS ARE CORRECT; IS IT PENALIZING IF ONE STREAM CROSSES THE PINCH POINT; IE COLD STREAM GOES FROM 50 TO 80\n\n5.1.1 Pasteurisation\n\n\nCode\nimport pandas as pd\nimport numpy as np\nfrom IPython.display import display, HTML\n\npast_pen = {'Exchangers': ['Refrigeration', 'Past1', 'Past2', 'Past3', 'Past4', 'Past5', 'Past6', 'Past7', 'Mixer'],\n        'Penalizing': ['Not Penalizing', 'Penalizing', 'Penalizing', 'Penalizing', 'Not Penalizing', 'Penalizing', 'Penalizing', 'Penalizing', 'Not Penalizing'],\n        'Penalty (kW)': ['0', '1691.65', '142.88', '285.76', '0', '17.52', '35.61', '127', '0']}\ndf = pd.DataFrame(past_pen)\ndf = df.set_index('Exchangers')\ndf = df.round(2)\nHTML(df.to_html())\n\n\n\n\n\n\nPenalizing\nPenalty (kW)\n\n\nExchangers\n\n\n\n\n\n\nRefrigeration\nNot Penalizing\n0\n\n\nPast1\nPenalizing\n1691.65\n\n\nPast2\nPenalizing\n142.88\n\n\nPast3\nPenalizing\n285.76\n\n\nPast4\nNot Penalizing\n0\n\n\nPast5\nPenalizing\n17.52\n\n\nPast6\nPenalizing\n35.61\n\n\nPast7\nPenalizing\n127\n\n\nMixer\nNot Penalizing\n0\n\n\n\n\n\n\n\n5.1.2 Evaporation\nTO BE CORRECTED ONCE THE EVAPORATION SECTION IS CORRECTED\nThe evaporators are equivalent to mixers.\n\n\nCode\nevap_pen = {'Exchangers': ['P1', 'P2', 'P3', 'P4', 'P5', 'Evap1', 'Evap2', 'Evap3'],\n        'Penalizing': ['Not Penalizing', 'Not Penalizing', 'Not Penalizing', 'Not Penalizing', 'Penalizing', 'Penalizing', 'Not Penalizing', 'Not Penalizing'],\n        'Penalty (kW)': ['0', '0', '0', '0', '98.04', '453.44', '0', '0']}\ndf = pd.DataFrame(evap_pen)\ndf = df.set_index('Exchangers')\nHTML(df.to_html())\n\n\n\n\n\n\nPenalizing\nPenalty (kW)\n\n\nExchangers\n\n\n\n\n\n\nP1\nNot Penalizing\n0\n\n\nP2\nNot Penalizing\n0\n\n\nP3\nNot Penalizing\n0\n\n\nP4\nNot Penalizing\n0\n\n\nP5\nPenalizing\n98.04\n\n\nEvap1\nPenalizing\n453.44\n\n\nEvap2\nNot Penalizing\n0\n\n\nEvap3\nNot Penalizing\n0\n\n\n\n\n\n\n\n5.1.3 Drum Dryers\n\n\nCode\ndryer_pen = {'Exchangers': ['Dryer 1', 'Dryer 2', 'DDHEX-1', 'DDHEX-2', 'Cooling Water'],\n        'Penalizing': ['Not Penalizing', 'Penalizing', 'Penalizing', 'Not Penalizing', 'Not Penalizing'],\n        'Penalty (kW)': ['0', '67.08', '0.11', '0', '0']}\ndf = pd.DataFrame(dryer_pen)\ndf = df.set_index('Exchangers')\nHTML(df.to_html())\n\n\n\n\n\n\nPenalizing\nPenalty (kW)\n\n\nExchangers\n\n\n\n\n\n\nDryer 1\nNot Penalizing\n0\n\n\nDryer 2\nPenalizing\n67.08\n\n\nDDHEX-1\nPenalizing\n0.11\n\n\nDDHEX-2\nNot Penalizing\n0\n\n\nCooling Water\nNot Penalizing\n0\n\n\n\n\n\n\n\n5.1.4 Cleaning in Place\n\n\nCode\nCIP_pen = {'Exchangers': ['Mixer', 'CIP-HEX', 'Shower-1', 'Shower-2', 'Cooling Water'],\n        'Penalizing': ['Penalizing', 'Penalizing', 'Penalizing', 'Penalizing', 'Penalizing'],\n        'Penalty (kW)': ['175.81', '334.72', '41.84', '41.84', '225.94']}\ndf = pd.DataFrame(CIP_pen)\ndf = df.set_index('Exchangers')\nHTML(df.to_html())\n\n\n\n\n\n\nPenalizing\nPenalty (kW)\n\n\nExchangers\n\n\n\n\n\n\nMixer\nPenalizing\n175.81\n\n\nCIP-HEX\nPenalizing\n334.72\n\n\nShower-1\nPenalizing\n41.84\n\n\nShower-2\nPenalizing\n41.84\n\n\nCooling Water\nPenalizing\n225.94\n\n\n\n\n\n\n\n5.1.5 Rivella Production\nR-Mixer1 and R-Mixer2 are ignored because there is no heat exchange occurring in these mixers.\n\n\nCode\nriv_pen = {'Exchangers': ['Fermentation', 'Evaporator', 'R-HEX1', 'R-Mixer3', 'Green Rivella HEX', 'R-Mixer4', 'Red Rivella HEX'],\n        'Penalizing': ['Not Penalizing', 'Penalizing', 'Penalizing', 'Not Penalizing', 'Not Penalizing', 'Not Penalizing', 'Not Penalizing'],\n        'Penalty (kW)': ['0', '579.42', '40.11', '0', '0', '0', '0']}\ndf = pd.DataFrame(riv_pen)\ndf = df.set_index('Exchangers')\nHTML(df.to_html())\n\n\n\n\n\n\nPenalizing\nPenalty (kW)\n\n\nExchangers\n\n\n\n\n\n\nFermentation\nNot Penalizing\n0\n\n\nEvaporator\nPenalizing\n579.42\n\n\nR-HEX1\nPenalizing\n40.11\n\n\nR-Mixer3\nNot Penalizing\n0\n\n\nGreen Rivella HEX\nNot Penalizing\n0\n\n\nR-Mixer4\nNot Penalizing\n0\n\n\nRed Rivella HEX\nNot Penalizing\n0\n\n\n\n\n\n\n\n5.1.6 Digester\n\n\nCode\ndig_pen = {'Exchangers': ['Digestor', 'Steam Dryer'],\n        'Penalizing': ['Not Penalizing', 'Penalizing'],\n        'Penalty (kW)': ['0', '28.75']}\ndf = pd.DataFrame(dig_pen)\ndf = df.set_index('Exchangers')\nHTML(df.to_html())\n\n\n\n\n\n\nPenalizing\nPenalty (kW)\n\n\nExchangers\n\n\n\n\n\n\nDigestor\nNot Penalizing\n0\n\n\nSteam Dryer\nPenalizing\n28.75"
  },
  {
    "objectID": "05.00-HeatExhangerNetwork.html#application-of-pinch-design-method",
    "href": "05.00-HeatExhangerNetwork.html#application-of-pinch-design-method",
    "title": "5  Heat Exchanger Network design",
    "section": "5.2 Application of Pinch Design Method",
    "text": "5.2 Application of Pinch Design Method\nDetermine the composite curves and identify the pinch point for each subset. This step also helps define the list of utility streams to be considered for the heat exchanger network design.\nImplement the pinch design method to generate a network configuration. With each heat exchanger placement, calculate the heat exchanged, flow rates, temperature conditions, size, and corresponding cost. Utilize loop and path following techniques to attempt the elimination of small heat exchangers. Evaluate the trade-off between cost (changes in the energy bill) and benefits (investment) in this process.\n\n5.2.1 Path following methods\n…\n\n\n5.2.2 Loop Method\n…\n\nDon’t forget that we have provided examples in the guide book."
  },
  {
    "objectID": "06.00-Utilityintegration.html",
    "href": "06.00-Utilityintegration.html",
    "title": "6  Energy conversion integration",
    "section": "",
    "text": "Once the heat recovery is implemented, the energy balance of the process system is closed by converting energy resources like natural and electricity into useful heat, cold or refrigeration heat loads for the process.\nYou will proceed by the following steps :\n\nGenerating the Grand composite curve (GCC) of the process system and analysing the temperature levels and the amount for the heat deficits and surplus in the system.\nFrom the Grand composite curve analysis, a list of possible energy conversion technologies like boilers, steam or Rankine cycles, heat pumps, cooling water or refrigeration system will be established. The hot and cold streams as well as the resources consumption/production as well as the associated investment will be defined based on the estimated heat loads and temperatures from the process system GCC.\nSystem Key Performance Indicators (KPI) will be defined to characterise :\n\nthe operating expenditure (OPEX) in [CHF/year]: cost of the resources and the waste flows to supply the energy requirements of the process on a yearly basis.\nthe capital expenditure (CAPEX) in [CHF]: the investment associated with energy conversion units\nthe total expenditure (TOTEX) in [CHF/year]: total cost of the energy supply considering the annualised investment and operating cost\nthe exergy losses in [kW] or in [kJ/kg_{product}] when converting hte resources to useful heat, electricity, cooling and refrigeration needs.\nthe emissions in [kg_{CO_{2}}/year] and the associated life cycle environmental impact in [kg_{CO_{2}eq}/year] of the energy supply.\n\nThe energy conversion system integration is calculated by calculating the relative flows (level of usage) in the energy conversion system. The flows are calculated based on a given set of energy conversion unit and with one of the KPI as an objective. This calculation aims at discovering synergies or complementarities between energy covnersion technologies to suppply the process energy needs.\nIn particular, the integration of the soda production will be investigated, by making a sensitivity analysis of the capacity on the soda production process.\nThe systematic generation of alternative system configuration options will allow to compare the different options and select the final recommendation."
  },
  {
    "objectID": "07-Conclusions.html",
    "href": "07-Conclusions.html",
    "title": "7  Conclusions",
    "section": "",
    "text": "As we reach the conclusion of your report, it’s important to note that a standard conclusion typically comprises the following components:\n\nSummary of main findings, highlighting the core findings and takeaways from your study.\nSignificance and contribution of the study\nFuture reasearch directions\nLimitations and prospects for improvement\n\nWe also encourage you to share your overall impressions of this course. Did you find the project interesting? How about the workload – was it manageable or particularly challenging? Were the instructions and guidance provided helpful throughout the course?\nWe greatly appreciate your feedback, as it will be valuable in enhancing the learning experience for upcoming cohorts. Thank you for taking the time to share your thoughts and suggestions.\n\nExample of a good conclusion\nThe presented carbon intensity supply curve can provide quantitative insights into China’s crude-oil supply by modelling the heterogeneity of oil resources in planning climate-informed strategies for the future of mobility. The data-driven analysis used here would allow improved information for producers, consumers and regulators about the energy returns and carbon intensities of oil to this critical global economy. The presented analysis would also allow an economically informed consequential LCA of China’s climate policy. This however requires substantial future work on developing a micro-founded econometric model of oil supply.\nThis study underlies a China-specific crude well-to-wheel LCA that can be utilized for China’a transportation studies; for example, they will be incorporated into the China GREET model to estimate GHG emissions of petroleum fuels from wells to wheels28. Furthermore, the presented bottom-up approach and the results in this paper can inform long-term climate and integrated assessment models by better modelling the heterogeneity in global oilfields.\nThe results presented in this work are limited by lack of access to reliable public data. Despite the enormous effort devoted to collect data in this work, access to more publicly available reliable data is crucial to perform a more comprehensive assessment in the future. Expanding the study to include more global oils is necessary to compare greater volumes of crudes. Better climate information about emerging oil resources is needed to increase market efficiency, expand choices, leverage opportunities and address climate challenges.\n– Masnadi et al. (2018)\n\n\nReferences\n\n\n“Eurostat Electricity Price Statistics.” n.d. Accessed\nNovember 14, 2023. https://ec.europa.eu/eurostat/statistics-explained/index.php?title=Electricity_price_statistics.\n\n\n“Eurostat Natural Gas Price Statistics.” n.d. Accessed\nNovember 14, 2023. https://ec.europa.eu/eurostat/statistics-explained/index.php?title=Natural_gas_price_statistics.\n\n\nHolliger, Christof, Hélène Fruteau de Laclos, and Gabrielle Hack. 2017.\n“Methane Production of Full-Scale Anaerobic\nDigestion Plants Calculated from Substrate’s\nBiomethane Potentials Compares Well with the One\nMeasured On-Site.” Frontiers in Energy Research 5\n(June): 12. https://doi.org/10.3389/fenrg.2017.00012.\n\n\nJing, Liang, Hassan M El-Houjeiri, Jean-Christophe Monfort, Adam R\nBrandt, Mohammad S Masnadi, Deborah Gordon, and Joule A Bergerson. 2020.\n“Carbon Intensity of Global Crude Oil Refining and Mitigation\nPotential.” Nature Climate Change 10 (6): 526–32.\n\n\nMasnadi, Mohammad S, Hassan M El-Houjeiri, Dominik Schunack, Yunpo Li,\nSamori O Roberts, Steven Przesmitzki, Adam R Brandt, and Michael Wang.\n2018. “Well-to-Refinery Emissions and Net-Energy Analysis of\nChina’s Crude-Oil Supply.” Nature Energy 3 (3): 220–26.\n\n\nNaghavi, Enayat-Allah, Jalal Dehghannya, and Babak Ghanbarzadeh. 2018.\n“3D Computational Simulation for the Prediction of Coupled\nMomentum, Heat and Mass Transfer During Deep-Fat Frying of Potato Strips\nCoated with Different Concentrations of Alginate.” Journal of\nFood Engineering 235: 64–78. https://doi.org/https://doi.org/10.1016/j.jfoodeng.2018.04.026.\n\n\nShi, W., M. G. Healy, S. M. Ashekuzzaman, K. Daly, J. J. Leahy, and O.\nFenton. 2021. “Dairy Processing Sludge and Co-Products:\nA Review of Present and Future Re-Use Pathways in\nAgriculture.” Journal of Cleaner Production 314\n(September): 128035. https://doi.org/10.1016/j.jclepro.2021.128035.\n\n\n“Table of Specific Heats.” n.d.\nAccessed November 14, 2023. http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/sphtt.html#c1."
  },
  {
    "objectID": "04.00-HeatRecovery.html",
    "href": "04.00-HeatRecovery.html",
    "title": "4  Title",
    "section": "",
    "text": "5 Pinch analysis\nStarting from this chapter, you will embark on optimizing the energy efficiency of the dairy factory. This section is divided into two parts:"
  }
]