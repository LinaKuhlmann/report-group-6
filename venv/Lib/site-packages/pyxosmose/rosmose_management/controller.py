# All rights reserved. ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE, Switzerland,
# IPESE Laboratory, Copyright 2018
# This work can be distributed under the CC BY-NC-SA 4.0 License.
# See the LICENSE file for more details.
#
# Author: Michel Lopez <michel.lopez@epfl.ch>
import json
import os.path
import tempfile
import subprocess
import psutil
import os
import signal
import time
from shutil import make_archive, copyfile, copyfileobj, rmtree
from pyxosmose.solvers.communication.utils import load_key
from cryptography.fernet import Fernet
from pathlib import Path
from distutils.dir_util import copy_tree
from pyxosmose.serializers.et import EtSerializer
from pyxosmose.serializers.graph_et import EtGraphSerializer
from pyxosmose.serializers.csvdata import CsvSerializer
from pyxosmose.serializers.frontend import FrontendSerializer
from pyxosmose.parser.json_parser import Parser
from pyxosmose.solvers.communication.xosmose_client import XosmoseClient
from pyxosmose.solvers.communication.xaspen_client import XaspenClient
from pyxosmose.solvers.communication.xvali_client import XvaliClient
from pyxosmose.solvers.osmose_solver import OsmoseSolver
from pyxosmose.solvers.vali_solver import ValiSolver
from pyxosmose.solvers.aspen_solver import AspenSolver


def stop_current_streamlit_running():
    for proc in psutil.process_iter(['pid', 'name']):
        if proc.info['name'] == 'streamlit' and "compare-tool.py" in proc.cmdline():
            os.kill(proc.info['pid'], signal.SIGKILL)


def launch_streamlit(workdir):
    script = "compare-tool.py"
    subprocess.Popen(["streamlit", "run", script], stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=workdir)
    time.sleep(5)

def write(directory="", filename="", text=""):
    directory = Path(directory)
    path = directory / filename
    directory.mkdir(parents=True, exist_ok=True)
    with open(path, 'w') as f:
        f.write(text)


def add_extra_files(target_dir=""):
    if target_dir != "":
        if os.path.exists(target_dir):
            pathtemp = os.path.join(os.path.dirname(os.path.realpath(__file__)), "../extra_files")
            copy_tree(pathtemp, target_dir)


def create_project_filesystem(project, data_path, output="project"):
    dirpath = Path(data_path)
    if dirpath.exists() and dirpath.is_dir():
        rmtree(dirpath)
    dirpath.mkdir(parents=True, exist_ok=True)
    for et in project.ets:
        serialize_et(et, data_path)
    serialize_frontend(project, data_path)
    with tempfile.TemporaryDirectory() as tmpdirname:
        make_archive(tmpdirname + "/" + output, 'zip', root_dir=data_path)
        copyfile(tmpdirname + "/" + output + ".zip", data_path + "/" + output + ".zip")
    return data_path + '/'+output+'.zip'


def serialize_frontend(project, data_path="./temp"):
    res_cwd = Path(data_path + "/projects")
    res_cwd.mkdir(parents=True, exist_ok=True)
    with tempfile.TemporaryDirectory() as tmpdirname:
        if int(project.periods) > 1:
            for et in project.ets:
                csv_serializer = CsvSerializer(et)
                write(tmpdirname + "/projects", et.name + "modeldata.csv", csv_serializer.serialize())
                copyfile(tmpdirname + "/projects/" + et.name + "modeldata.csv",
                         str(res_cwd) + "/" + et.name + "modeldata.csv")
        frontend_serializer = FrontendSerializer(project)
        frontend_text, opdata = frontend_serializer.serialize()
        write(tmpdirname + "/projects", "frontend.lua", frontend_text)
        write(tmpdirname + "/projects", "operating_data.csv", opdata)
        copyfile(tmpdirname + "/projects/frontend.lua", str(res_cwd) + "/frontend.lua")
        copyfile(tmpdirname + "/projects/operating_data.csv", str(res_cwd) + "/operating_data.csv")
        return res_cwd


def serialize_et(et, data_path="./temp"):
    with tempfile.TemporaryDirectory() as tmpdirname:
        serializer = EtSerializer(et)
        write(tmpdirname + "/ET", et.name + ".lua", serializer.serialize())
        res_cwd = Path(data_path + "/ET")
        res_cwd.mkdir(parents=True, exist_ok=True)
        copyfile(tmpdirname + "/ET/" + et.name + ".lua", data_path + "/ET/" + et.name + ".lua")
        return data_path + "/ET"


def local_solve_osmose(project_path):
    solver = OsmoseSolver(project_path)
    objective, result = solver.solve()
    if objective is None and result == "solved?":
        message = "Osmose was not able to solve the optimization."
        raise Exception(message)

    for root, dirs, files in os.walk(project_path + '/results'):
        for file in files:
            if file.endswith(".json"):
                json_output = os.path.join(root, file)
                with open(json_output, 'r') as f:
                    data = json.load(f)
                return data
    return None


def solve_osmose(input_zip_path, file_name):
    key = load_key()
    f = Fernet(key)
    xosmose_rpc = XosmoseClient()
    response = xosmose_rpc.call('osmose', input_zip_path, file_name)
    response = response.decode('utf-8')
    response = json.loads(response)
    if not isinstance(response['result'], dict):
        if response['result'].startswith("Error:"):
            byte_file = bytes(response['zip_file'], encoding='utf8')
            decrypted_file = f.decrypt(byte_file)
            with open('error.zip', 'wb') as file:
                file.write(decrypted_file)
            raise Exception(response['result'])
    else:
        byte_file = bytes(response['zip_file'], encoding='utf8')
        decrypted_file = f.decrypt(byte_file)
        return response['result'], decrypted_file


def local_solve_aspen(input_model_path, model_input, model_output=None):
    if os.name != 'nt':
        raise Exception("Aspen works only on Windows... Use SOLVE instead of SOLVE-LOCAL to remotely solve this model")
    if model_output is None:
        model_output = []
    output_path = str(Path(input_model_path).parents[0])
    file_name = Path(input_model_path).name
    solver = AspenSolver(input_model_path)
    for el in model_input:
        if "path" in el and "value" in el:
            solver.set_value(el['path'], el['value'])
    solver.run()
    res = solver.get_outputs(model_output)
    solver.close()
    return res


def solve_aspen(input_model_path, file_name, model_input, model_output, output_path=None):
    xaspen_rpc = XaspenClient()
    response = xaspen_rpc.call('aspen', input_model_path, file_name, model_input, model_output)
    if response.decode('utf-8') == 'Error':
        raise Exception("The server was not able to solve the osmose project")
    if output_path is not None:
        with open(output_path + '/aspen-result.json', 'wb') as f:
            f.write(response)
    return json.loads(response)


def local_solve_vali(input_model_path, model_input, model_output=None, input_file=None):
    if os.name != 'nt':
        raise Exception("Vali works only on Windows... Use SOLVE instead of SOLVE-LOCAL to remotely solve this model")
    if model_output is None:
        model_output = []
    output_path = str(Path(input_model_path).parents[0])
    file_name = Path(input_model_path).name
    solver = ValiSolver(output_path)
    if input_file:
        run_file = solver.generate_vali_files_with_input(file_name, input_file)
    else:
        run_file = solver.generate_vali_files(file_name, model_input)
    ret = {}
    ret['run'] = solver.solve(run_file)
    return ret


def solve_vali(input_model_path, file_name, model_input, model_output=None, output_path=None, run="run"):
    if model_output is None:
        model_output = []
    xvali_rpc = XvaliClient()
    response = xvali_rpc.call('vali', input_model_path, file_name, model_input, model_output)
    if response.decode('utf-8') == 'Error':
        raise Exception("The server was not able to solve the osmose project")
    if output_path is not None:
        with open(output_path + '/vali-result.json', 'wb') as f:
            f.write(response)
    ret = {}
    if response.decode('utf-8') != 'Error':
        ret[run] = json.loads(response)
    else:
        ret[run] = ['Error']
    return ret


def get_et_graphviz(et, time='default'):
    serializer = EtGraphSerializer(et, time)
    return serializer.serialize()


def parse_result(json_path):
    return Parser(json_path)
