from pyxosmose.rosmose_management.chunks_utility import *


class SoftwareManager:
    def __init__(self, tags):
        self.__software = []
        self.__tags = tags

    @property
    def software(self):
        return self.__software

    @software.setter
    def software(self, value):
        if type(value) is list:
            self.__software = value
        else:
            raise TypeError('Expected software as list')

    def add_model(self, model):
        if type(model) is dict:
            self.__software.append(model)

    def get_model_by_name(self, name):
        models = list(filter(lambda model: model['name'] == name, self.__software))
        if len(models) > 0:
            return models[0]
        raise Exception("Error: No MODEL found with name: " + name)

    def create_new_model(self, model_name, code):
        software_data = retrieve_table_content(code)
        values = software_data[0].split("|")[1:-1]
        values = self.__tags.replace_tags(values)
        model = None
        if len(values) == 3:
            model = {
                'name': model_name,
                'software': values[0],
                'model_path': values[1],
                'comment': values[2],
                'inputs': [],
                'outputs': []
            }
        elif len(values) == 2:
            model = {
                'name': model_name,
                'software': values[0],
                'model_path': None,
                'comment': values[1],
                'inputs': [],
                'outputs': []
            }
        if model is not None:
            self.add_model(model)

    def add_model_inputs(self, model_name, code):
        input_data = retrieve_table_content(code)
        model = self.get_model_by_name(model_name)
        if model['software'] == 'VALI':
            for line in input_data:
                value = line.split("|")[1:-1]
                value = self.__tags.replace_tags(value)
                tag = self.__tags.generate_tag('vali', value)
                tmp_input = list(filter(lambda model_input: model_input["name"] == tag.name, model['inputs']))
                if len(tmp_input) > 0:
                    inputs = [x for x in model['inputs'] if not (x["name"] == tag.name)]
                    model['inputs'] = inputs
                model['inputs'].append({
                    'name': tag.name,
                    'value': tag.value,
                    'min': tag.min,
                    'max': tag.max,
                    'unit': tag.unit,
                    'description': tag.description
                })
        elif model['software'] == 'ASPEN':
            for line in input_data:
                value = line.split("|")[1:-1]
                value = self.__tags.replace_tags(value)
                tag = self.__tags.generate_tag('aspen', value)
                tmp_input = list(filter(lambda software_input: software_input["name"] == tag.name, model['inputs']))
                if len(tmp_input) > 0:
                    inputs = [x for x in model['inputs'] if not (x["name"] == tag.name)]
                    model['inputs'] = inputs
                model['inputs'].append({
                    'name': tag.name,
                    'value': tag.value,
                    'unit': tag.unit,
                    'description': tag.description,
                    'path': tag.path
                })

    def add_model_outputs(self, model_name, code):
        output_data = retrieve_table_content(code)
        model = self.get_model_by_name(model_name)
        if model['software'] == 'VALI':
            for line in output_data:
                value = line.split("|")[1:-1]
                value = self.__tags.replace_tags(value)
                tag = self.__tags.generate_tag('vali', value)
                model['outputs'].append({
                    'name': tag.name,
                    'unit': tag.unit,
                    'description': tag.description
                })
        elif model['software'] == 'ASPEN':
            for line in output_data:
                value = line.split("|")[1:-1]
                value = self.__tags.replace_tags(value)
                tag = self.__tags.generate_tag('aspen', value)
                model['outputs'].append({
                    'name': tag.name,
                    'unit': tag.unit,
                    'description': tag.description,
                    'path': tag.path
                })

    def reset_model_inputs(self, model_name):
        model = self.get_model_by_name(model_name)
        inputs_name = [x["name"] for x in model["inputs"]]
        for name in inputs_name:
            for i in range(len(model["inputs"])):
                if model["inputs"][i]["name"] == name:
                    del model["inputs"][i]
                    break
            for i in range(len(self.__tags.tags)):
                if self.__tags.tags[i].name == name:
                    del self.__tags.tags[i]
                    break

    def reset_model_outputs(self, model_name):
        model = self.get_model_by_name(model_name)
        outputs_name = [x["name"] for x in model["outputs"]]
        for name in outputs_name:
            for i in range(len(model["outputs"])):
                if model["outputs"][i]["name"] == name:
                    del model["outputs"][i]
                    break
            for i in range(len(self.__tags.tags)):
                if self.__tags.tags[i].name == name:
                    del self.__tags.tags[i]
                    break

    def retrieve_models_and_args_from_model_name(self, model_name):
        arguments = []
        if "[" in model_name and "]" in model_name:
            elements = model_name.split("[")
            model_name = elements[0]
            arguments_txt = elements[1][:-1].lower()
            for chars in arguments_txt:
                if chars == "n":
                    arguments.append("name")
                elif chars == "v":
                    arguments.append("value")
                elif chars == "u":
                    arguments.append("unit")
                elif chars == "p":
                    arguments.append("path")
                elif chars == "c" or chars == "d":
                    arguments.append("description")
        model = self.get_model_by_name(model_name)
        return model, arguments

    def get_model_inputs(self, model_name):
        model, arguments = self.retrieve_models_and_args_from_model_name(model_name)
        inputs = []
        if len(arguments) > 0:
            for model_input in model["inputs"]:
                temp = {}
                for arg in arguments:
                    if arg in model_input:
                        temp[arg] = model_input[arg]
                inputs.append(temp)
            return inputs
        return model["inputs"]

    def get_model_outputs(self, model_name):
        model, arguments = self.retrieve_models_and_args_from_model_name(model_name)
        outputs = []
        if len(arguments) > 0:
            for output in model["outputs"]:
                temp = {}
                for arg in arguments:
                    if arg in output:
                        temp[arg] = output[arg]
                outputs.append(temp)
            return outputs
        return model["outputs"]

    def add_model_interfaces(self, model_name, code):
        output_data = retrieve_code_content(code)
        model = self.get_model_by_name(model_name)
        if model['software'] == 'VALI':
            for line in output_data:
                if line is not None and line != "" and not line.startswith("#"):
                    if ">>" in line:
                        elements = line.split(">>")
                        minimum = ""
                        maximum = ""
                        var_name, unit, description, data = retrieve_data_from_meta_language(elements)
                        if ":" in data:
                            vals = data.split(":")
                            if len(vals) == 2:
                                minimum = vals[0]
                                data = vals[1]
                                maximum = vals[1]
                            elif len(vals) == 3:
                                minimum = vals[0]
                                data = vals[1]
                                maximum = vals[2]
                        value = data.strip()
                        tag = self.__tags.generate_tag('vali', [var_name, value, minimum, maximum, unit, description])
                        model['inputs'].append({
                            'name': tag.name,
                            'value': tag.value,
                            'min': tag.min,
                            'max': tag.max,
                            'unit': tag.unit,
                            'description': tag.description,
                        })
                    elif "<<" in line:
                        elements = line.split("<<")
                        var_name, unit, description, data = retrieve_data_from_meta_language(elements)
                        tag = self.__tags.generate_tag('vali', [var_name, unit, description])
                        model['outputs'].append({
                            'name': tag.name,
                            'unit': tag.unit,
                            'description': tag.description,
                        })

        elif model['software'] == 'ASPEN':
            for line in output_data:
                if ">>" in line:
                    elements = line.split(">>")
                    var_name = elements[0].strip()
                    data = elements[1].split("=")
                    path = data[0].strip()
                    data = data[1]
                    description = ""
                    if "#" in data:
                        data = data.split("#")
                        description = data[1].strip()
                        data = data[0]
                    unit = ""
                    if "[" in data and "]" in data:
                        unit = data[data.find("[") + 1:data.find("]")]
                        data = data.split("[")
                        data = data[0]
                    value = data.strip()
                    tag = self.__tags.generate_tag('aspen', [var_name, path, value, unit, description])
                    model['inputs'].append({
                        'name': tag.name,
                        'value': tag.value,
                        'unit': tag.unit,
                        'description': tag.description,
                        'path': tag.path
                    })
                elif "<<" in line:
                    elements = line.split("<<")
                    var_name, unit, description, data = retrieve_data_from_meta_language(elements)
                    path = data.strip()
                    tag = self.__tags.generate_tag('aspen', [var_name, path, unit, description])
                    model['outputs'].append({
                        'name': tag.name,
                        'unit': tag.unit,
                        'description': tag.description,
                        'path': tag.path
                    })

    def update_outputs_after_solve(self, model_name, result):
        model = self.get_model_by_name(model_name)
        if model['software'] == 'VALI':
            if len(model['outputs']) > 0:
                for output in model['outputs']:
                    el = next(x for x in result["run"] if x["name"] == output["name"])
                    tag = self.__tags.generate_tag("vali", [el["name"], str(el["job"]),
                                                            el["unit"], output["description"]])
                    model['outputs'].remove(output)
                    model['outputs'].append({
                        'name': tag.name,
                        'value': tag.value,
                        'unit': tag.unit,
                        'description': tag.description,
                        'path': tag.path
                    })
                return model["outputs"]
            for el in result['run']:
                tag = self.__tags.generate_tag("vali", [el["name"], str(el["job"]), el["unit"], ""])
                model['outputs'].append({
                    'name': tag.name,
                    'value': tag.value,
                    'unit': tag.unit,
                    'description': tag.description,
                    'path': tag.path
                })
            return model["outputs"]
        elif model['software'] == 'ASPEN':
            model["outputs"] = []
            for el in result:
                tag = self.__tags.generate_tag("aspen", [el["name"], el["path"],
                                                         str(el["job"]), el["unit"], el["description"]])
                model['outputs'].append({
                    'name': tag.name,
                    'value': tag.value,
                    'unit': tag.unit,
                    'description': tag.description,
                    'path': tag.path
                })
            return model["outputs"]
