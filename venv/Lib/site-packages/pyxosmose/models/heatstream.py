# All rights reserved. ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE, Switzerland,
# IPESE Laboratory, Copyright 2018
# This work can be distributed under the CC BY-NC-SA 4.0 License.
# See the LICENSE file for more details.
#
# Author: Michel Lopez <michel.lopez@epfl.ch>


class HeatStreamData:

    def __init__(self, tin='', tout='', hin='', hout='', hval='', dtmin='', alpha='', dtmin_tin='', dtmin_tout='', temperature_unit='CÂ°', hentalpy_unit='kW', is_heat_constant=False, is_heating=False):
        self.__tin = tin
        self.__tout = tout
        self.__hin = hin
        self.__hout = hout
        self.__hval = hval
        self.__dtmin = dtmin
        self.__alpha = alpha
        self.__dtmin_tin = dtmin_tin
        self.__dtmin_tout = dtmin_tout
        self.__temperature_unit = temperature_unit
        self.__hentalpy_unit = hentalpy_unit
        self.__is_heat_constant = is_heat_constant
        self.__is_heating = is_heating

    @property
    def tin(self):
        return self.__tin

    @tin.setter
    def tin(self, value):
        if type(value) is str:
            self.__tin = value
        else:
            raise TypeError('Expected value as str')

    @property
    def tout(self):
        return self.__tout

    @tout.setter
    def tout(self, value):
        if type(value) is str:
            self.__tout = value
        else:
            raise TypeError('Expected value as str')

    @property
    def hin(self):
        return self.__hin

    @hin.setter
    def hin(self, value):
        if type(value) is str:
            self.__hin = value
        else:
            raise TypeError('Expected value as str')

    @property
    def hout(self):
        return self.__hout

    @hout.setter
    def hout(self, value):
        if type(value) is str:
            self.__hout = value
        else:
            raise TypeError('Expected value as str')

    @property
    def hval(self):
        if float(self.__hin) > 0:
            return self.__hin
        return self.__hout

    @hval.setter
    def hval(self, value):
        if type(value) is str:
            self.__hval = value
        else:
            raise TypeError('Expected value as str')

    @property
    def dtmin(self):
        return self.__dtmin

    @dtmin.setter
    def dtmin(self, value):
        if type(value) is str:
            self.__dtmin = value
        else:
            raise TypeError('Expected value as str')

    @property
    def alpha(self):
        return self.__alpha

    @alpha.setter
    def alpha(self, value):
        if type(value) is str:
            self.__alpha = value
        else:
            raise TypeError('Expected value as str')

    @property
    def temperature_unit(self):
        return self.__temperature_unit

    @temperature_unit.setter
    def temperature_unit(self, value):
        if type(value) is str:
            self.__temperature_unit = value
        else:
            raise TypeError('Expected value as str')

    @property
    def hentalpy_unit(self):
        return self.__hentalpy_unit

    @hentalpy_unit.setter
    def hentalpy_unit(self, value):
        if type(value) is str:
            self.__hentalpy_unit = value
        else:
            raise TypeError('Expected value as str')

    @property
    def is_heat_constant(self):
        if float(self.__tin) == float(self.__tout):
            return True
        return False

    @is_heat_constant.setter
    def is_heat_constant(self, value):
        if type(value) is bool:
            self.__is_heat_constant = value
        else:
            raise TypeError('Expected value as bool')

    @property
    def is_heating(self):
        if float(self.__tout) > float(self.__tin):
            return True
        return False

    @is_heating.setter
    def is_heating(self, value):
        if type(value) is bool:
            self.__is_heating = value
        else:
            raise TypeError('Expected value as bool')

    @property
    def dtmin_tin(self):
        if not self.is_heat_constant:
            if self.is_heating:
                return str(float(self.__tin)-float(self.__dtmin))
            else:
                return str(float(self.__tin)+float(self.__dtmin))
        return self.__tin

    @dtmin_tin.setter
    def dtmin_tin(self, value):
        if type(value) is str:
            self.__dtmin_tin = value
        else:
            raise TypeError('Expected value as str')

    @property
    def dtmin_tout(self):
        if not self.is_heat_constant:
            if self.is_heating:
                return str(float(self.__tout)-float(self.__dtmin))
            else:
                return str(float(self.__tout)+float(self.__dtmin))
        return self.__tout

    @dtmin_tout.setter
    def dtmin_tout(self, value):
        if type(value) is str:
            self.__dtmin_tout = value
        else:
            raise TypeError('Expected value as str')

    def __eq__(self, other):
        if not isinstance(other, HeatStreamData):
            # don't attempt to compare against unrelated types
            return NotImplemented
        return self.__tin == other.__tin \
               and self.__tout == other.__tout \
               and self.__hin == other.__hin \
               and self.__hout == other.__hout \
               and self.__dtmin == other.__dtmin \
               and self.__alpha == other.__alpha
