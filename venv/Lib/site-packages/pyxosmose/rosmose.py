from pyxosmose.rosmose_management.osmose_manager import OsmoseManager
from pyxosmose.rosmose_management.tags_manager import TagsManager
from pyxosmose.rosmose_management.model_manager import SoftwareManager
from pyxosmose.rosmose_management.chunks_utility import *
from pyxosmose.rosmose_management.controller import *
from pyxosmose.bibdata.bibdata_management import BibDataManagement
from pyxosmose.models.tag import Tag
from tomark import Tomark
from pathlib import Path
import shutil
import re
import pandas as pd
import glob


class Rosmose:
    def __init__(self):
        self.__tags_manager = TagsManager()
        self.__osmose_manager = OsmoseManager(self.__tags_manager)
        self.__software_manager = SoftwareManager(self.__tags_manager)
        self.__bib_data = []

    @property
    def osmose_manager(self):
        return self.__osmose_manager

    @osmose_manager.setter
    def osmose_manager(self, value):
        if type(value) is OsmoseManager:
            self.__osmose_manager = value
        else:
            raise TypeError('Expected value as OsmoseManager')

    @property
    def software_manager(self):
        return self.__software_manager

    @software_manager.setter
    def software_manager(self, value):
        if type(value) is SoftwareManager:
            self.__software_manager = value
        else:
            raise TypeError('Expected value as SoftwareManager')

    @property
    def tags_manager(self):
        return self.__tags_manager

    @tags_manager.setter
    def tags_manager(self, value):
        if type(value) is TagsManager:
            self.__tags_manager = value
        else:
            raise TypeError('Expected value as TagsManager')

    @property
    def bib_data(self):
        return self.__bib_data

    @bib_data.setter
    def bib_data(self, value):
        if type(value) is list:
            self.__bib_data = value
        else:
            raise TypeError('Expected bib_data as list')

    def get_bib_data_by_name(self, name):
        data = list(filter(lambda t: t["name"] == "test", self.__bib_data))
        if len(data) > 0:
            return data[0]["bibdata"]

    def display_tags(self, header, code):
        table = []
        lines = code.split("\n")[1:]
        for line in lines:
            if line is not None and line != "":
                if not line.startswith("#"):
                    line = line.strip()
                    if line.startswith("%") and line.endswith("%"):
                        line = line[1:-1]
                    line = line.split(" ")[0]
                    table.append(line)
        if len(table) == 0:
            for tag in self.__tags_manager.tags:
                table.append(tag.name)
        arguments = ['name', 'value', 'unit', 'description', 'path']
        if header.startswith("[") and header.endswith("]"):
            arguments = []
            arguments_txt = header[1:-1].lower()
            for chars in arguments_txt:
                if chars == "n":
                    arguments.append("name")
                elif chars == "v":
                    arguments.append("value")
                elif chars == "u":
                    arguments.append("unit")
                elif chars == "p":
                    arguments.append("path")
                elif chars == "c" or chars == "d":
                    arguments.append("description")
        result = []
        for el in table:
            for tag in self.__tags_manager.tags:
                if tag.name == el:
                    temp = {}
                    for arg in arguments:
                        val = ""
                        if arg == "name":
                            val = tag.name
                        elif arg == "value":
                            val = tag.value
                        elif arg == "unit":
                            val = tag.unit
                        elif arg == "description":
                            val = tag.description
                        elif arg == "path":
                            val = tag.path
                        temp[arg] = val
                    result.append(temp)
        return result

    def display_et(self, elements):
        Path('./images').mkdir(parents=True, exist_ok=True)
        energy_technology = self.__osmose_manager.get_et_by_name(elements["name"])
        if energy_technology is not None:
            if elements['period'] is None:
                return get_et_graphviz(energy_technology)
            else:
                return get_et_graphviz(energy_technology, time=elements['period'])

    def render_ets(self, element):
        my_ets = []
        if "[" in element and "]" in element:
            data = element[element.find("[") + 1:element.find("]")]
            my_ets = data.split(",")
        else:
            my_ets.append(element)
        for et_name in my_ets:
            temp_et = self.__osmose_manager.get_et_by_name(et_name)
            if temp_et is not None:
                serialize_et(temp_et)
            else:
                error_message = "Error: No ET found with name: " + et_name
                raise Exception(error_message)

    def render_project(self, element, code):
        project_data = retrieve_table_content(code)
        project = self.__osmose_manager.create_project_object(element, project_data)
        tmp = Path("./temp")
        tmp.mkdir(parents=True, exist_ok=True)
        return serialize_frontend(project, str(tmp))

    def solve_model(self, model_name, local_solve=False, input_file=None):
        model = self.__software_manager.get_model_by_name(model_name)
        name = Path(model['model_path']).name
        if model['software'] == 'VALI':
            if local_solve:
                res_cwd = Path("./result/model")
                res_cwd.mkdir(parents=True, exist_ok=True)
                shutil.copy(model['model_path'], str(res_cwd))
                model_path = res_cwd / name
                if input_file:
                    shutil.copy(input_file, str(res_cwd))
                    input_file = Path(input_file).name
                result = local_solve_vali(str(model_path), model['inputs'], model['outputs'], input_file=input_file)
            else:
                result = solve_vali(model['model_path'], name, model['inputs'], model['outputs'])
            return self.__software_manager.update_outputs_after_solve(model_name, result)
        if model['software'] == 'ASPEN':
            if local_solve:
                res_cwd = Path("./result/model")
                res_cwd.mkdir(parents=True, exist_ok=True)
                shutil.copy(model['model_path'], str(res_cwd))
                model_path = res_cwd / name
                result = local_solve_aspen(str(model_path), model['inputs'], model['outputs'])
            else:
                result = solve_aspen(model['model_path'], name, model['inputs'], model['outputs'])
            return self.__software_manager.update_outputs_after_solve(model_name, result)

    def solve_osmose_project(self, element, code, force_update=False, local_solve=False):
        project_data = retrieve_table_content(code)
        project = self.__osmose_manager.create_project_object(element, project_data)
        zip_path = create_project_filesystem(project, "./temp")
        res_cwd = Path("./result")
        res_cwd.mkdir(parents=True, exist_ok=True)
        if local_solve:
            result_dict = local_solve_osmose("./temp")
        else:
            result_dict, run_zip = solve_osmose(zip_path, 'project.zip')
            with open('./result/runned.zip', 'wb') as file:
                file.write(run_zip)

        jsons = glob.glob("./result/" + element["project_name"] + "*.json")
        jsons = [re.search(element["project_name"] + '(.*).json', os.path.basename(x)).group(1) for x in jsons]
        jsons = list(filter(None, jsons))
        jsons = [int(x[1:]) for x in jsons]
        run_number = 1
        if len(jsons) > 0:
            max_num_run = max(jsons)
            run_number = max_num_run + 1
        json_file = './result/' + element["project_name"] + '-' + str(run_number) + '.json'
        with open(json_file, 'w') as f:
            f.write(json.dumps(result_dict))
        if not Path('./result/execution-report.Rmd').is_file() or force_update:
            add_extra_files('./result')
        shutil.rmtree("./temp")
        stop_current_streamlit_running()
        launch_streamlit('./result')
        return json_file, './result/execution-report.Rmd'

    def make_calculation(self, code):
        tag_list = re.findall(r'%(.*?)%', code)
        for tag_name in tag_list:
            tag = self.__tags_manager.get_tag_by_name(tag_name)
            if tag is not None:
                if tag.value != "":
                    code = code.replace("%" + tag_name + "%", tag.value)
                else:
                    raise Exception(tag_name + " TAG have no value... check the definition of this tag")
            else:
                raise Exception("TAG with name " + tag_name + " does not exists. Please define it before using it")
        x = eval(code)
        return str(x)

    def manage_console(self, code):
        lines = code.split("\n")
        for line in lines:
            if line is not None and line != "" and not line.startswith("#"):
                if "=" in line:
                    elements = line.split("=")
                    var_name, unit, description, data = retrieve_data_from_meta_language(elements)
                    tag = Tag()
                    is_new_tag = True
                    for t in self.__tags_manager.tags:
                        if t.name == var_name:
                            tag = t
                            is_new_tag = False
                    if "+" in data or "-" in data or "*" in data or "/" in data:
                        value = self.make_calculation(data)
                        if is_new_tag:
                            tag.name = var_name
                            tag.value = value
                            tag.unit = unit
                            tag.description = description
                            self.__tags_manager.tags.append(tag)
                        else:
                            if value != tag.value and value != "":
                                tag.value = value
                            if unit != tag.unit and unit != "":
                                tag.unit = unit
                            if description != tag.description and description != "":
                                tag.description = description
                    else:
                        value = data.strip()
                        if is_number(value):
                            if value != tag.value and value != "":
                                tag.value = value
                            if description != tag.description and description != "":
                                tag.description = description
                            if unit != tag.unit and unit != "":
                                tag.unit = unit
                            if is_new_tag:
                                tag.name = var_name
                                self.__tags_manager.tags.append(tag)
                        else:
                            raise Exception(var_name + " TAG have no correct value... check the definition of this tag")

    def read_bib_data(self, filename, bib_data_file_path, default_value):
        bibdata = BibDataManagement(bib_data_file_path, default_value)
        data = bibdata.get_database()
        self.__bib_data.append({"name": filename, "bibdata": bibdata})
        return pd.DataFrame.from_records(data)

    def manage_osmose_type(self, title, file_name, code, display):
        elements = title.split(" ")
        et_name = ""
        if file_name is not None and file_name != "":
            et_name = file_name.split(".")[0]
        if elements[1] == 'ET':
            if len(elements) == 3:
                et_name = elements[2]
            self.__osmose_manager.create_et(et_name, code)
        elif elements[1] == 'LAYERS':
            if len(elements) == 3:
                et_name = elements[2]
            self.__osmose_manager.add_layers_to_et(et_name, code)
        elif elements[1] == 'UNIT':
            if len(elements) == 3:
                et_name = elements[2]
            self.__osmose_manager.add_unit_to_et(et_name, code)
        elif elements[1] == 'UNIT_PARAM':
            res = self.__osmose_manager.add_unit_param(elements[2], code)
            return display, "custom_view", Tomark.table(res)
        elif elements[1] == 'RESOURCE_STREAMS':
            res = self.__osmose_manager.add_unit_resource_streams(elements[2], code)
            return display, "custom_view", Tomark.table(res)
        elif elements[1] == 'HEAT_STREAMS':
            res = self.__osmose_manager.add_unit_heat_streams(elements[2], code)
            return display, "custom_view", Tomark.table(res)
        elif elements[1] == 'DISPLAY_ET':
            if len(elements) == 3:
                et_name = elements[2]
            et_dict = {'name': et_name, 'period': None}
            return display, "display_et", self.display_et(et_dict), et_name
        elif elements[1] == 'SAVE_ET':
            if len(elements) == 3:
                et_name = elements[2]
            self.__osmose_manager.save_et(et_name)
            return display, ""
        elif elements[1] == 'SERIALIZE_ET':
            if len(elements) > 2:
                energy_technologies_text = ""
                for x in range(2, len(elements)):
                    energy_technologies_text = energy_technologies_text + elements[x]
                self.render_ets(energy_technologies_text)
                return display, ""
            if et_name != "":
                self.render_ets(et_name)
                return display, ""
        elif elements[1] == 'SERIALIZE_PROJECT':
            ets_txt = retrieve_ets_from_solve_args(elements)
            project = {'project_name': elements[2], 'objective': elements[3], 'ets': ets_txt}
            self.render_project(project, code)
        elif elements[1] == 'SOLVE':
            ets_txt = retrieve_ets_from_solve_args(elements)
            project = {'project_name': elements[2], 'objective': elements[3], 'ets': ets_txt}
            json_file, rmd_file = self.solve_osmose_project(project, code)
            return display, "osmose_solve", json_file, rmd_file
        elif elements[1] == "SOLVE-LOCAL":
            ets_txt = retrieve_ets_from_solve_args(elements)
            project = {'project_name': elements[2], 'objective': elements[3], 'ets': ets_txt}
            json_file, rmd_file = self.solve_osmose_project(project, code, local_solve=True)
            return display, "osmose_solve", json_file, rmd_file
        elif elements[1] == "LOAD-RESULT":
            return display, "osmose_load_result", elements[2]
        elif elements[1] == 'OPTIONS':
            if len(elements) == 3:
                options_name = elements[2]
                self.__osmose_manager.create_option(options_name, code)
        return display, elements[1], code

    def manage_model_type(self, title, code, display):
        elements = title.split(" ")
        if len(elements) == 2:
            self.__software_manager.create_new_model(elements[1], code)
        else:
            if elements[1] == "INPUTS":
                self.__software_manager.add_model_inputs(elements[2], code)
            elif elements[1] == "OUTPUTS":
                self.__software_manager.add_model_outputs(elements[2], code)
            elif elements[1] == "INTERFACES":
                self.__software_manager.add_model_interfaces(elements[2], code)
            elif elements[1] == "RESET-INPUTS":
                self.__software_manager.reset_model_inputs(elements[2])
            elif elements[1] == "RESET-OUTPUTS":
                self.__software_manager.reset_model_outputs(elements[2])
            elif elements[1] == "DISPLAY_INPUTS":
                if len(elements) > 3:
                    if elements[3].startswith("[") and elements[3].endswith("]"):
                        elements[2] = elements[2] + elements[3]
                res = self.__software_manager.get_model_inputs(elements[2])
                return display, "custom_view", Tomark.table(res)
            elif elements[1] == "DISPLAY_OUTPUTS":
                if len(elements) > 3:
                    if elements[3].startswith("[") and elements[3].endswith("]"):
                        elements[2] = elements[2] + elements[3]
                res = self.__software_manager.get_model_outputs(elements[2])
                return display, "custom_view", Tomark.table(res)
            elif elements[1] == "SOLVE":
                res = self.solve_model(elements[2])
                if isinstance(res, list):
                    return display, "custom_view", Tomark.table(res)
                elif isinstance(res, dict):
                    return display, "custom_view", Tomark.table(res["run"])
                return display, "solve", code
            elif elements[1] == "SOLVE-LOCAL":
                input_file = None
                if len(elements) == 4:
                    input_file = elements[3]
                res = self.solve_model(elements[2], local_solve=True, input_file = input_file)
                return display, "solve-local", Tomark.table(res)
        return display, elements[1], code

    def manage_tags_type(self, title, code, display):
        elements = title.split(" ")
        if len(elements) == 1:
            # TODO: section for create tags with table style
            return "new", elements[0]
        else:
            if elements[1] == "DISPLAY_TAGS":
                if len(elements) > 2:
                    if elements[2].startswith("[") and elements[2].endswith("]"):
                        elements[0] = elements[2]
                res = self.display_tags(elements[0], code)
                return display, "custom_view", Tomark.table(res)
            elif elements[1] == "SAVE":
                self.__tags_manager.save_tags()
                return display, ""
            elif elements[1] == "LOAD":
                self.__tags_manager.load_tags()
                return display, ""
            return display, elements[1], code

    def retrieve_type(self, code, file_name=""):
        lines = code.split("\n")
        display = False
        if lines[0][0] == ':':
            display = True
        if lines[0][0] == ':' or lines[0][0] == '!':
            title = lines[0][1:].strip()
            if title.startswith("MODEL"):
                return self.manage_model_type(title, code, display)
            elif title.startswith("OSMOSE"):
                return self.manage_osmose_type(title, file_name, code, display)
            elif title.startswith("TAGS"):
                return self.manage_tags_type(title, code, display)
        if lines[0][0] == '#':
            return display
        else:
            self.manage_console(code)
            return display
