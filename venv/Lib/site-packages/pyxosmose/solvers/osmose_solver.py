import os
import subprocess
import psutil
import time

from pyxosmose.solvers.app_own_exception import SolverError


class OsmoseSolver:
    def __init__(self, cwd):
        self.__calculation_repository = cwd

    def solve(self):
        output = self.exec_osmose()
        return self.parse_objective_result(output)

    @staticmethod
    def parse_objective_result(osmose_result):
        lines = osmose_result.split('\n')
        objective = ''
        result = ''
        for line in lines:
            if line.startswith("RESULT"):
                objectives = line.split('=')[1].split(':')
                objective = objectives[0]
                result = objectives[1]
                pass
            if "solved?" in line:
                objective = None
                result = "solved?"
        return objective, result

    def exec_osmose(self):
        frontend_path = os.path.join("projects", "frontend.lua")
        commands = '''lua5.1 {}'''.format(frontend_path)
        my_env = os.environ.copy()
        p = subprocess.Popen(commands, shell=True, cwd=self.__calculation_repository, env=my_env, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        output, err = p.communicate()
        decoded_output = output.decode('utf-8')
        decoded_err = err.decode('utf-8')
        if decoded_err != '':
            self.create_error_file(decoded_err)
            err = decoded_err.split('\n')
            err = " ".join(err)
            if "Output created: " not in decoded_err:
                raise SolverError(self.__calculation_repository, err)
        self.create_output_file(decoded_output)
        return decoded_output

    def create_output_file(self, output):
        with open(os.path.join(self.__calculation_repository, "result.txt"), "w") as f:
            f.write(output)

    def create_error_file(self, error):
        with open(os.path.join(self.__calculation_repository, "error.txt"), "w") as f:
            f.write(error)

    @staticmethod
    def close():
        process_name = "alic_run.exe"

        for proc in psutil.process_iter():
            # check whether the process name matches
            if proc.name() == process_name:
                proc.kill()

        time.sleep(5)
